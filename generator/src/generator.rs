use anyhow::{anyhow, bail, ensure, Context, Result};
use rustdoc_types::{
    Crate, Enum, GenericArg, GenericArgs, GenericBound, GenericParamDefKind, Generics, Id, Item,
    ItemEnum, Struct, Type, Variant, WherePredicate,
};
use std::{
    collections::{HashMap, HashSet},
    fmt::Write,
};

use crate::PackageConfig;

macro_rules! here {
    ($message:tt) => {
        format!("[{}:{}] {}", file!(), line!(), format!($message))
    };
}

struct Generator<'a> {
    krate: &'a Crate,
    out: String,
    config: &'a PackageConfig,
}

pub(crate) fn generate(krate: &Crate, config: &PackageConfig) -> Result<String> {
    let mut out = String::new();
    out.push_str("// AUTOGENERATED FILE, DO NOT EDIT\n");
    out.push_str("//\n");

    let name = krate.index[&krate.root]
        .name
        .as_ref()
        .ok_or_else(|| anyhow!("No name"))?;
    let version = krate
        .crate_version
        .as_ref()
        .ok_or_else(|| anyhow!("No version"))?;

    let root_id = krate.index[&krate.root].crate_id;

    writeln!(out, "// Crate Name: `{}`", name)?;
    writeln!(out, "// Crate Version: `{}`", version)?;

    let mut gen = Generator { krate, out, config };

    let mut items = krate.index.values().collect::<Vec<_>>();
    items.sort_by_key(|item| gen.path_of(&item.id).ok());

    for item in items {
        if item.crate_id != root_id {
            continue;
        }

        match &item.inner {
            ItemEnum::Enum(enumm) => {
                gen.generate_enum(item, enumm)?;
            }
            ItemEnum::Struct(strukt) => {
                gen.generate_struct(item, strukt)?;
            }
            _ => {}
        }
    }

    Ok(gen.out)
}

impl Generator<'_> {
    fn generate_enum(&mut self, item: &Item, enumm: &Enum) -> Result<()> {
        let path = self.path_of(&item.id)?;

        let simple_name = path.split_once("::").unwrap().1;
        if let Some(p) = self.config.exclude.iter().find(|x| x.matches(simple_name)) {
            writeln!(self.out, "// Skiping {path} due to config rule {p}")?;
            return Ok(());
        }

        let mut tys = Vec::new();
        for i in &enumm.variants {
            if let ItemEnum::Variant(v) = &self.krate.index[&i].inner {
                match v {
                    Variant::Plain => {}
                    Variant::Tuple(fields) => tys.extend(fields),
                    Variant::Struct(fields) => {
                        for f in fields {
                            if let ItemEnum::StructField(f) = &self.krate.index[f].inner {
                                tys.push(f)
                            } else {
                                bail!("Expected type fields here");
                            }
                        }
                    }
                }
            }
        }

        let (igen, tgen, where_) = self
            .extract_generics(&enumm.generics, &tys)
            .with_context(|| here!("Cannot extract generics for {path}"))?;

        writeln!(
            self.out,
            "impl<{igen}>  crate::Debug for {path}<{tgen}> where {where_} {{"
        )?;
        writeln!(self.out, "    fn fmt(&self, f: &mut crate::Formatter) {{")?;
        writeln!(self.out, "        match self {{")?;

        for i in &enumm.variants {
            let v_item = &self.krate.index[i];
            let v_name = v_item.name.as_ref().ok_or_else(|| anyhow!("No name"))?;
            let non_exhaustive = v_item.attrs.iter().any(|x| x == "#[non_exhaustive]");

            if let ItemEnum::Variant(varient) = &v_item.inner {
                write!(self.out, "            Self::{v_name} ")?;
                match varient {
                    Variant::Plain => {
                        // if non_exhaustive {
                        //     write!(self.out, "(..)")?;
                        // }
                        writeln!(self.out, "=> {{ f.debug_tuple({v_name:?}).finish(); }}")?
                    }
                    Variant::Tuple(fields) => {
                        write!(self.out, "(")?;
                        for i in 0..fields.len() {
                            write!(self.out, "__{}, ", i)?;
                        }
                        if non_exhaustive {
                            write!(self.out, "..")?;
                        }
                        write!(self.out, ") => {{ f.debug_tuple({v_name:?})")?;
                        for i in 0..fields.len() {
                            write!(self.out, ".field(__{i})")?;
                        }
                        writeln!(self.out, ".finish(); }}")?;
                    }
                    Variant::Struct(fields) => {
                        write!(self.out, "{{")?;

                        for i in fields {
                            let f_name = self.krate.index[i]
                                .name
                                .as_ref()
                                .ok_or_else(|| anyhow!("No name"))?;
                            write!(self.out, "{f_name}, ")?;
                        }
                        if non_exhaustive {
                            write!(self.out, "..")?;
                        }

                        writeln!(self.out, " }} => {{")?;
                        writeln!(self.out, "            f.debug_struct({v_name:?})")?;
                        for i in fields {
                            let f_name = field_name_of(
                                self.krate.index[i]
                                    .name
                                    .as_ref()
                                    .ok_or_else(|| anyhow!("No name"))?,
                            );
                            writeln!(self.out, "                .field({f_name:?}, {f_name})")?;
                        }
                        writeln!(self.out, "                .finish()")?;
                        writeln!(self.out, "        }}")?;
                    }
                }
            } else {
                bail!("Excpeced Variant");
            }
        }

        // TODO: Document #[non_exaustive] in JSON
        if enumm.variants_stripped || item.attrs.iter().any(|x| x == "#[non_exhaustive]") {
            writeln!(self.out, "            _ => {{ \"???\".fmt(f) }}")?;
        }

        writeln!(self.out, "        }}")?;
        writeln!(self.out, "    }}")?;
        writeln!(self.out, "}}")?;

        Ok(())
    }

    fn generate_struct(&mut self, item: &Item, strukt: &Struct) -> Result<()> {
        // let path = self.path_of(&item.id).context()?;
        let path = match self.path_of(&item.id) {
            Ok(path) => path,
            Err(_) => {
                // Not all public items have paths
                // See https://github.com/rust-lang/rust/issues/96161
                writeln!(
                    self.out,
                    "// Skiping struct {:?} due to not having path",
                    item.name
                )?;
                return Ok(());
            }
        };

        let simple_name = path.split_once("::").unwrap().1;
        if let Some(p) = self.config.exclude.iter().find(|x| x.matches(simple_name)) {
            writeln!(self.out, "// Skiping {path} due to config rule {p}")?;
            return Ok(());
        }

        if strukt.fields_stripped {
            writeln!(self.out, "// Skipping {path} due to hidden fields")?;
            return Ok(());
        }

        let mut tys = Vec::new();
        for f in &strukt.fields {
            if let ItemEnum::StructField(ty) = &self.krate.index[f].inner {
                tys.push(ty);
            } else {
                bail!("Expected StructField")
            }
        }

        let (igen, tgen, where_) = self
            .extract_generics(&strukt.generics, &tys)
            .with_context(|| here!("Cannot get generics for struct {path}"))?;

        writeln!(
            self.out,
            "impl<{igen}> crate::Debug for {path}<{tgen}>  where {where_} {{"
        )?;
        writeln!(self.out, "    fn fmt(&self, f: &mut crate::Formatter) {{")?;

        let name = item.name.as_ref().ok_or_else(|| anyhow!("No name"))?;

        let striped = strukt.fields_stripped;

        if striped {
            writeln!(self.out, "        // Warning: Striped Fields")?;
        }

        match strukt.struct_type {
            rustdoc_types::StructType::Plain => {
                writeln!(self.out, "        f.debug_struct({name:?})")?;
                for i in &strukt.fields {
                    let f_name = field_name_of(
                        self.krate.index[i]
                            .name
                            .as_ref()
                            .ok_or_else(|| anyhow!("No name"))?,
                    );
                    writeln!(self.out, "            .field({f_name:?}, &self.{f_name})")?;
                }
                writeln!(self.out, "            .finish()")?;
            }
            rustdoc_types::StructType::Tuple => {
                write!(self.out, "f.debug_tuple({name:?})")?;
                for i in 0..strukt.fields.len() {
                    write!(self.out, ".field(&self.{i})")?;
                }
                write!(self.out, ".finish()")?;
            }
            rustdoc_types::StructType::Unit => {
                writeln!(self.out, "        f.debug_struct({name:?})")?;
                writeln!(self.out, "            .finish()")?;
            }
        }

        writeln!(self.out, "    }}\n}}")?;

        Ok(())
    }

    fn extract_generics(
        &self,
        generics: &Generics,
        fields: &[&Type],
    ) -> Result<(String, String, String)> {
        let mut impl_ = String::new();
        let mut type_ = String::new();
        let mut where_ = String::new();

        // Map of generic name to what to do about it
        let mut map = BoundsMap::new();
        // Order generics appear for type
        let mut order = Vec::new();

        for i in &generics.params {
            match &i.kind {
                GenericParamDefKind::Lifetime { .. } => {
                    order.push(i.to_owned());
                }
                GenericParamDefKind::Type {
                    bounds, default, ..
                } => {
                    let mut n_bounds = BoundsInfo {
                        bounds: String::new(),
                        useing_default: false,
                        default: default.to_owned(),
                    };
                    match self.write_where_pred(&Type::Generic(i.name.to_owned()), &bounds) {
                        Ok(b) => n_bounds.bounds = b,
                        Err(e) => {
                            if n_bounds.default.is_some() {
                                n_bounds.useing_default = true;
                            } else {
                                return Err(e);
                            }
                        }
                    }
                    map.insert(i.name.to_owned(), n_bounds);
                    order.push(i.to_owned());
                }
                GenericParamDefKind::Const { .. } => todo!(),
            }
        }

        for i in &generics.where_predicates {
            match i {
                WherePredicate::BoundPredicate { type_, bounds, .. } => {
                    if let Type::Generic(name) = type_ {
                        let old_bounds = map.get_mut(name).unwrap();
                        match self.write_where_pred(type_, bounds) {
                            Ok(b) => old_bounds.bounds.push_str(&b),
                            Err(e) => {
                                if old_bounds.default.is_some() {
                                    old_bounds.useing_default = true
                                } else {
                                    return Err(e);
                                }
                            }
                        }
                    } else {
                        write!(where_, "{}", self.write_where_pred(type_, bounds)?)?;
                    }
                }
                WherePredicate::RegionPredicate { .. } => todo!(),
                WherePredicate::EqPredicate { .. } => todo!(),
            }
        }

        for i in &order {
            match &i.kind {
                GenericParamDefKind::Lifetime { outlives } => {
                    ensure!(outlives.is_empty());
                    write!(impl_, "{},", i.name)?;
                    write!(type_, "{},", i.name)?;
                }
                GenericParamDefKind::Type { .. } => {
                    let bounds = &map[&i.name];
                    if !bounds.useing_default {
                        write!(impl_, "{},", i.name)?;
                        write!(type_, "{},", i.name)?;
                    }
                }
                GenericParamDefKind::Const { .. } => todo!(),
            }
        }

        let mut seen = HashSet::new();
        for &i in fields {
            if seen.contains(i) {
                continue;
            }
            if is_generic(i)? {
                write!(
                    where_,
                    "{}: crate::Debug,",
                    self.print_type_with_bm(i, &map)?
                )?;
            }
            seen.insert(i);
        }

        Ok((impl_, type_, where_))
    }

    fn write_where_pred(&self, type_: &Type, bounds: &[GenericBound]) -> Result<String> {
        let type_s = self.print_type(type_)?;
        let bounds_s = bounds
            .iter()
            .map(|b| {
                self.print_bound(b)
                    .with_context(|| here!("Cannot create bound {type_s} implements {b:?}"))
            })
            .collect::<Result<Vec<_>, _>>()?
            .join("+");
        Ok(format!("{type_s}: {bounds_s},"))
    }

    fn path_of(&self, id: &Id) -> Result<String> {
        Ok(self
            .krate
            .paths
            .get(id)
            .ok_or_else(|| anyhow!("No Path for {id:?}"))?
            // .unwrap()
            .path
            .join("::"))
    }

    fn print_type(&self, ty: &Type) -> Result<String> {
        self.print_type_with_bm(ty, &BoundsMap::new())
    }

    fn print_type_with_bm(&self, ty: &Type, bm: &BoundsMap) -> Result<String> {
        match ty {
            Type::ResolvedPath {
                id,
                args,
                param_names,
                ..
            } => {
                ensure!(param_names.is_empty(), here!("Got {param_names:?}"));
                let path = self
                    .path_of(id)
                    .with_context(|| here!("Cannot print Resoved Path {id:?}"))?;
                let args = match args {
                    Some(args) => self.print_args(args, bm)?,
                    None => String::new(),
                };
                Ok(format!("{path}<{args}>"))
            }
            Type::Generic(name) => Ok(name.to_owned()),
            Type::Primitive(name) => Ok(name.to_owned()),
            Type::FunctionPointer(_) => todo!(),
            Type::Tuple(ids) => {
                let names = ids
                    .iter()
                    .map(|i| self.print_type(i))
                    .collect::<Result<Vec<_>, _>>()?;
                Ok(format!("({})", names.join(",")))
            }
            Type::Slice(_) => todo!(),
            Type::Array { .. } => todo!(),
            Type::ImplTrait(_) => todo!(),
            Type::Infer => todo!(),
            Type::RawPointer { .. } => todo!(),
            Type::BorrowedRef { .. } => todo!(),
            Type::QualifiedPath { .. } => todo!(),
        }
    }

    fn print_bound(&self, bound: &GenericBound) -> Result<String> {
        match bound {
            GenericBound::TraitBound {
                trait_,
                generic_params,
                modifier,
            } => {
                ensure!(generic_params.len() == 0);

                let trait_name = self
                    .print_type(trait_)
                    .with_context(|| here!("Cannot print bound {bound:?}"))?;

                match modifier {
                    rustdoc_types::TraitBoundModifier::None => Ok(trait_name),
                    rustdoc_types::TraitBoundModifier::Maybe => Ok(format!("?{trait_name}")),
                    rustdoc_types::TraitBoundModifier::MaybeConst => todo!(),
                }
            }
            GenericBound::Outlives(name) => Ok(name.to_owned()),
        }
    }

    pub(crate) fn print_args(&self, args: &GenericArgs, bm: &BoundsMap) -> Result<String> {
        match args {
            GenericArgs::AngleBracketed { args, bindings } => {
                ensure!(bindings == &[]);
                let mut out = String::new();
                for i in args {
                    match i {
                        GenericArg::Lifetime(l) => write!(out, "{l},")?,
                        GenericArg::Type(ty) => {
                            if let Type::Generic(name) = ty {
                                if let Some(b_info) = bm.get(name) {
                                    if b_info.useing_default {
                                        // TODO: Check that the default is the same
                                        continue;
                                    }
                                }
                            }
                            write!(out, "{},", self.print_type_with_bm(ty, bm)?)?;
                        }
                        GenericArg::Const(_) => todo!(),
                        GenericArg::Infer => todo!(),
                    }
                }
                Ok(out)
            }
            GenericArgs::Parenthesized { .. } => todo!(),
        }
    }
}

fn field_name_of(name: &str) -> &str {
    match name {
        "type" => "r#type",
        "return" => "r#return",
        _ => name,
    }
}

fn is_generic(i: &Type) -> Result<bool> {
    Ok(match i {
        Type::ResolvedPath {
            name,
            id,
            args,
            param_names,
        } => {
            // ensure!(param_names.is_empty(), here!("Got {param_names:?}"));
            match args {
                Some(x) => match &**x {
                    GenericArgs::AngleBracketed { args, bindings } => {
                        ensure!(bindings.is_empty());
                        try_any(args.iter().map(|i| is_generic_arg(i)))?
                    }
                    GenericArgs::Parenthesized { inputs, output } => todo!(),
                },
                None => false,
            }
        }
        Type::Generic(_) => true,
        Type::Primitive(_) => false,
        Type::FunctionPointer(_) => todo!(),
        Type::Tuple(tys) => try_any(tys.iter().map(|i| is_generic(i)))?,
        Type::Slice(_) => todo!(),
        Type::Array { type_, len } => todo!(),
        Type::ImplTrait(_) => todo!(),
        Type::Infer => todo!(),
        Type::RawPointer { mutable, type_ } => todo!(),
        Type::BorrowedRef {
            lifetime,
            mutable,
            type_,
        } => todo!(),
        Type::QualifiedPath {
            name,
            args,
            self_type,
            trait_,
        } => todo!(),
    })
}

fn is_generic_arg(i: &GenericArg) -> Result<bool> {
    match i {
        GenericArg::Lifetime(_) => Ok(false),
        GenericArg::Type(t) => is_generic(t),
        GenericArg::Const(_) => todo!(),
        GenericArg::Infer => todo!(),
    }
}

fn try_any(x: impl Iterator<Item = Result<bool>>) -> Result<bool> {
    for i in x {
        if i? {
            return Ok(true);
        }
    }
    Ok(false)
}

struct BoundsInfo {
    bounds: String,
    useing_default: bool,
    default: Option<Type>,
}
type BoundsMap = HashMap<String, BoundsInfo>;
