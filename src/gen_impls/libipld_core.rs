// AUTOGENERATED FILE, DO NOT EDIT
//
// Crate Name: `libipld_core`
// Crate Version: `0.16.0`
impl crate::Debug for libipld_core::error::BlockNotFound {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_tuple("BlockNotFound").field(&self.0).finish()
    }
}
impl crate::Debug for libipld_core::error::BlockTooLarge {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_tuple("BlockTooLarge").field(&self.0).finish()
    }
}
impl crate::Debug for libipld_core::error::InvalidMultihash {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_tuple("InvalidMultihash").field(&self.0).finish()
    }
}
impl crate::Debug for libipld_core::error::TypeError {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeError")
            .field("expected", &self.expected)
            .field("found", &self.found)
            .finish()
    }
}
impl crate::Debug for libipld_core::error::TypeErrorType {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Null => {
                f.debug_tuple("Null").finish();
            }
            Self::Bool => {
                f.debug_tuple("Bool").finish();
            }
            Self::Integer => {
                f.debug_tuple("Integer").finish();
            }
            Self::Float => {
                f.debug_tuple("Float").finish();
            }
            Self::String => {
                f.debug_tuple("String").finish();
            }
            Self::Bytes => {
                f.debug_tuple("Bytes").finish();
            }
            Self::List => {
                f.debug_tuple("List").finish();
            }
            Self::Map => {
                f.debug_tuple("Map").finish();
            }
            Self::Link => {
                f.debug_tuple("Link").finish();
            }
            Self::Key(__0) => {
                f.debug_tuple("Key").field(__0).finish();
            }
            Self::Index(__0) => {
                f.debug_tuple("Index").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for libipld_core::error::UnsupportedCodec {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_tuple("UnsupportedCodec").field(&self.0).finish()
    }
}
impl crate::Debug for libipld_core::error::UnsupportedMultihash {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_tuple("UnsupportedMultihash")
            .field(&self.0)
            .finish()
    }
}
impl crate::Debug for libipld_core::ipld::Ipld {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Null => {
                f.debug_tuple("Null").finish();
            }
            Self::Bool(__0) => {
                f.debug_tuple("Bool").field(__0).finish();
            }
            Self::Integer(__0) => {
                f.debug_tuple("Integer").field(__0).finish();
            }
            Self::Float(__0) => {
                f.debug_tuple("Float").field(__0).finish();
            }
            Self::String(__0) => {
                f.debug_tuple("String").field(__0).finish();
            }
            Self::Bytes(__0) => {
                f.debug_tuple("Bytes").field(__0).finish();
            }
            Self::List(__0) => {
                f.debug_tuple("List").field(__0).finish();
            }
            Self::Map(__0) => {
                f.debug_tuple("Map").field(__0).finish();
            }
            Self::Link(__0) => {
                f.debug_tuple("Link").field(__0).finish();
            }
        }
    }
}
impl<'a> crate::Debug for libipld_core::ipld::IpldIndex<'a> {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::List(__0) => {
                f.debug_tuple("List").field(__0).finish();
            }
            Self::Map(__0) => {
                f.debug_tuple("Map").field(__0).finish();
            }
            Self::MapRef(__0) => {
                f.debug_tuple("MapRef").field(__0).finish();
            }
        }
    }
}
// Skipping libipld_core::ipld::IpldIter due to hidden fields
// Skipping libipld_core::link::Link due to hidden fields
impl crate::Debug for libipld_core::raw::RawCodec {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("RawCodec").finish()
    }
}
impl crate::Debug for libipld_core::raw_value::IgnoredAny {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("IgnoredAny").finish()
    }
}
// Skipping libipld_core::raw_value::RawValue due to hidden fields
