// AUTOGENERATED FILE, DO NOT EDIT
//
// Crate Name: `syn`
// Crate Version: `1.0.98`
impl crate::Debug for syn::Abi {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Abi")
            .field("extern_token", &self.extern_token)
            .field("name", &self.name)
            .finish()
    }
}
impl crate::Debug for syn::AngleBracketedGenericArguments {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("AngleBracketedGenericArguments")
            .field("colon2_token", &self.colon2_token)
            .field("lt_token", &self.lt_token)
            .field("args", &self.args)
            .field("gt_token", &self.gt_token)
            .finish()
    }
}
impl crate::Debug for syn::Arm {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Arm")
            .field("attrs", &self.attrs)
            .field("pat", &self.pat)
            .field("guard", &self.guard)
            .field("fat_arrow_token", &self.fat_arrow_token)
            .field("body", &self.body)
            .field("comma", &self.comma)
            .finish()
    }
}
impl crate::Debug for syn::AttrStyle {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Outer => {
                f.debug_tuple("Outer").finish();
            }
            Self::Inner(__0) => {
                f.debug_tuple("Inner").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::Attribute {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Attribute")
            .field("pound_token", &self.pound_token)
            .field("style", &self.style)
            .field("bracket_token", &self.bracket_token)
            .field("path", &self.path)
            .field("tokens", &self.tokens)
            .finish()
    }
}
impl crate::Debug for syn::BareFnArg {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("BareFnArg")
            .field("attrs", &self.attrs)
            .field("name", &self.name)
            .field("ty", &self.ty)
            .finish()
    }
}
impl crate::Debug for syn::BinOp {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Add(__0) => {
                f.debug_tuple("Add").field(__0).finish();
            }
            Self::Sub(__0) => {
                f.debug_tuple("Sub").field(__0).finish();
            }
            Self::Mul(__0) => {
                f.debug_tuple("Mul").field(__0).finish();
            }
            Self::Div(__0) => {
                f.debug_tuple("Div").field(__0).finish();
            }
            Self::Rem(__0) => {
                f.debug_tuple("Rem").field(__0).finish();
            }
            Self::And(__0) => {
                f.debug_tuple("And").field(__0).finish();
            }
            Self::Or(__0) => {
                f.debug_tuple("Or").field(__0).finish();
            }
            Self::BitXor(__0) => {
                f.debug_tuple("BitXor").field(__0).finish();
            }
            Self::BitAnd(__0) => {
                f.debug_tuple("BitAnd").field(__0).finish();
            }
            Self::BitOr(__0) => {
                f.debug_tuple("BitOr").field(__0).finish();
            }
            Self::Shl(__0) => {
                f.debug_tuple("Shl").field(__0).finish();
            }
            Self::Shr(__0) => {
                f.debug_tuple("Shr").field(__0).finish();
            }
            Self::Eq(__0) => {
                f.debug_tuple("Eq").field(__0).finish();
            }
            Self::Lt(__0) => {
                f.debug_tuple("Lt").field(__0).finish();
            }
            Self::Le(__0) => {
                f.debug_tuple("Le").field(__0).finish();
            }
            Self::Ne(__0) => {
                f.debug_tuple("Ne").field(__0).finish();
            }
            Self::Ge(__0) => {
                f.debug_tuple("Ge").field(__0).finish();
            }
            Self::Gt(__0) => {
                f.debug_tuple("Gt").field(__0).finish();
            }
            Self::AddEq(__0) => {
                f.debug_tuple("AddEq").field(__0).finish();
            }
            Self::SubEq(__0) => {
                f.debug_tuple("SubEq").field(__0).finish();
            }
            Self::MulEq(__0) => {
                f.debug_tuple("MulEq").field(__0).finish();
            }
            Self::DivEq(__0) => {
                f.debug_tuple("DivEq").field(__0).finish();
            }
            Self::RemEq(__0) => {
                f.debug_tuple("RemEq").field(__0).finish();
            }
            Self::BitXorEq(__0) => {
                f.debug_tuple("BitXorEq").field(__0).finish();
            }
            Self::BitAndEq(__0) => {
                f.debug_tuple("BitAndEq").field(__0).finish();
            }
            Self::BitOrEq(__0) => {
                f.debug_tuple("BitOrEq").field(__0).finish();
            }
            Self::ShlEq(__0) => {
                f.debug_tuple("ShlEq").field(__0).finish();
            }
            Self::ShrEq(__0) => {
                f.debug_tuple("ShrEq").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::Binding {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Binding")
            .field("ident", &self.ident)
            .field("eq_token", &self.eq_token)
            .field("ty", &self.ty)
            .finish()
    }
}
impl crate::Debug for syn::Block {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Block")
            .field("brace_token", &self.brace_token)
            .field("stmts", &self.stmts)
            .finish()
    }
}
impl crate::Debug for syn::BoundLifetimes {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("BoundLifetimes")
            .field("for_token", &self.for_token)
            .field("lt_token", &self.lt_token)
            .field("lifetimes", &self.lifetimes)
            .field("gt_token", &self.gt_token)
            .finish()
    }
}
impl crate::Debug for syn::ConstParam {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ConstParam")
            .field("attrs", &self.attrs)
            .field("const_token", &self.const_token)
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .field("eq_token", &self.eq_token)
            .field("default", &self.default)
            .finish()
    }
}
impl crate::Debug for syn::Constraint {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Constraint")
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("bounds", &self.bounds)
            .finish()
    }
}
impl crate::Debug for syn::Data {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Struct(__0) => {
                f.debug_tuple("Struct").field(__0).finish();
            }
            Self::Enum(__0) => {
                f.debug_tuple("Enum").field(__0).finish();
            }
            Self::Union(__0) => {
                f.debug_tuple("Union").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::DataEnum {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("DataEnum")
            .field("enum_token", &self.enum_token)
            .field("brace_token", &self.brace_token)
            .field("variants", &self.variants)
            .finish()
    }
}
impl crate::Debug for syn::DataStruct {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("DataStruct")
            .field("struct_token", &self.struct_token)
            .field("fields", &self.fields)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::DataUnion {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("DataUnion")
            .field("union_token", &self.union_token)
            .field("fields", &self.fields)
            .finish()
    }
}
impl crate::Debug for syn::DeriveInput {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("DeriveInput")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("data", &self.data)
            .finish()
    }
}
impl crate::Debug for syn::Expr {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Array(__0) => {
                f.debug_tuple("Array").field(__0).finish();
            }
            Self::Assign(__0) => {
                f.debug_tuple("Assign").field(__0).finish();
            }
            Self::AssignOp(__0) => {
                f.debug_tuple("AssignOp").field(__0).finish();
            }
            Self::Async(__0) => {
                f.debug_tuple("Async").field(__0).finish();
            }
            Self::Await(__0) => {
                f.debug_tuple("Await").field(__0).finish();
            }
            Self::Binary(__0) => {
                f.debug_tuple("Binary").field(__0).finish();
            }
            Self::Block(__0) => {
                f.debug_tuple("Block").field(__0).finish();
            }
            Self::Box(__0) => {
                f.debug_tuple("Box").field(__0).finish();
            }
            Self::Break(__0) => {
                f.debug_tuple("Break").field(__0).finish();
            }
            Self::Call(__0) => {
                f.debug_tuple("Call").field(__0).finish();
            }
            Self::Cast(__0) => {
                f.debug_tuple("Cast").field(__0).finish();
            }
            Self::Closure(__0) => {
                f.debug_tuple("Closure").field(__0).finish();
            }
            Self::Continue(__0) => {
                f.debug_tuple("Continue").field(__0).finish();
            }
            Self::Field(__0) => {
                f.debug_tuple("Field").field(__0).finish();
            }
            Self::ForLoop(__0) => {
                f.debug_tuple("ForLoop").field(__0).finish();
            }
            Self::Group(__0) => {
                f.debug_tuple("Group").field(__0).finish();
            }
            Self::If(__0) => {
                f.debug_tuple("If").field(__0).finish();
            }
            Self::Index(__0) => {
                f.debug_tuple("Index").field(__0).finish();
            }
            Self::Let(__0) => {
                f.debug_tuple("Let").field(__0).finish();
            }
            Self::Lit(__0) => {
                f.debug_tuple("Lit").field(__0).finish();
            }
            Self::Loop(__0) => {
                f.debug_tuple("Loop").field(__0).finish();
            }
            Self::Macro(__0) => {
                f.debug_tuple("Macro").field(__0).finish();
            }
            Self::Match(__0) => {
                f.debug_tuple("Match").field(__0).finish();
            }
            Self::MethodCall(__0) => {
                f.debug_tuple("MethodCall").field(__0).finish();
            }
            Self::Paren(__0) => {
                f.debug_tuple("Paren").field(__0).finish();
            }
            Self::Path(__0) => {
                f.debug_tuple("Path").field(__0).finish();
            }
            Self::Range(__0) => {
                f.debug_tuple("Range").field(__0).finish();
            }
            Self::Reference(__0) => {
                f.debug_tuple("Reference").field(__0).finish();
            }
            Self::Repeat(__0) => {
                f.debug_tuple("Repeat").field(__0).finish();
            }
            Self::Return(__0) => {
                f.debug_tuple("Return").field(__0).finish();
            }
            Self::Struct(__0) => {
                f.debug_tuple("Struct").field(__0).finish();
            }
            Self::Try(__0) => {
                f.debug_tuple("Try").field(__0).finish();
            }
            Self::TryBlock(__0) => {
                f.debug_tuple("TryBlock").field(__0).finish();
            }
            Self::Tuple(__0) => {
                f.debug_tuple("Tuple").field(__0).finish();
            }
            Self::Type(__0) => {
                f.debug_tuple("Type").field(__0).finish();
            }
            Self::Unary(__0) => {
                f.debug_tuple("Unary").field(__0).finish();
            }
            Self::Unsafe(__0) => {
                f.debug_tuple("Unsafe").field(__0).finish();
            }
            Self::Verbatim(__0) => {
                f.debug_tuple("Verbatim").field(__0).finish();
            }
            Self::While(__0) => {
                f.debug_tuple("While").field(__0).finish();
            }
            Self::Yield(__0) => {
                f.debug_tuple("Yield").field(__0).finish();
            }
            _ => "???".fmt(f),
        }
    }
}
impl crate::Debug for syn::ExprArray {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprArray")
            .field("attrs", &self.attrs)
            .field("bracket_token", &self.bracket_token)
            .field("elems", &self.elems)
            .finish()
    }
}
impl crate::Debug for syn::ExprAssign {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprAssign")
            .field("attrs", &self.attrs)
            .field("left", &self.left)
            .field("eq_token", &self.eq_token)
            .field("right", &self.right)
            .finish()
    }
}
impl crate::Debug for syn::ExprAssignOp {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprAssignOp")
            .field("attrs", &self.attrs)
            .field("left", &self.left)
            .field("op", &self.op)
            .field("right", &self.right)
            .finish()
    }
}
impl crate::Debug for syn::ExprAsync {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprAsync")
            .field("attrs", &self.attrs)
            .field("async_token", &self.async_token)
            .field("capture", &self.capture)
            .field("block", &self.block)
            .finish()
    }
}
impl crate::Debug for syn::ExprAwait {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprAwait")
            .field("attrs", &self.attrs)
            .field("base", &self.base)
            .field("dot_token", &self.dot_token)
            .field("await_token", &self.await_token)
            .finish()
    }
}
impl crate::Debug for syn::ExprBinary {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprBinary")
            .field("attrs", &self.attrs)
            .field("left", &self.left)
            .field("op", &self.op)
            .field("right", &self.right)
            .finish()
    }
}
impl crate::Debug for syn::ExprBlock {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprBlock")
            .field("attrs", &self.attrs)
            .field("label", &self.label)
            .field("block", &self.block)
            .finish()
    }
}
impl crate::Debug for syn::ExprBox {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprBox")
            .field("attrs", &self.attrs)
            .field("box_token", &self.box_token)
            .field("expr", &self.expr)
            .finish()
    }
}
impl crate::Debug for syn::ExprBreak {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprBreak")
            .field("attrs", &self.attrs)
            .field("break_token", &self.break_token)
            .field("label", &self.label)
            .field("expr", &self.expr)
            .finish()
    }
}
impl crate::Debug for syn::ExprCall {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprCall")
            .field("attrs", &self.attrs)
            .field("func", &self.func)
            .field("paren_token", &self.paren_token)
            .field("args", &self.args)
            .finish()
    }
}
impl crate::Debug for syn::ExprCast {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprCast")
            .field("attrs", &self.attrs)
            .field("expr", &self.expr)
            .field("as_token", &self.as_token)
            .field("ty", &self.ty)
            .finish()
    }
}
impl crate::Debug for syn::ExprClosure {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprClosure")
            .field("attrs", &self.attrs)
            .field("movability", &self.movability)
            .field("asyncness", &self.asyncness)
            .field("capture", &self.capture)
            .field("or1_token", &self.or1_token)
            .field("inputs", &self.inputs)
            .field("or2_token", &self.or2_token)
            .field("output", &self.output)
            .field("body", &self.body)
            .finish()
    }
}
impl crate::Debug for syn::ExprContinue {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprContinue")
            .field("attrs", &self.attrs)
            .field("continue_token", &self.continue_token)
            .field("label", &self.label)
            .finish()
    }
}
impl crate::Debug for syn::ExprField {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprField")
            .field("attrs", &self.attrs)
            .field("base", &self.base)
            .field("dot_token", &self.dot_token)
            .field("member", &self.member)
            .finish()
    }
}
impl crate::Debug for syn::ExprForLoop {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprForLoop")
            .field("attrs", &self.attrs)
            .field("label", &self.label)
            .field("for_token", &self.for_token)
            .field("pat", &self.pat)
            .field("in_token", &self.in_token)
            .field("expr", &self.expr)
            .field("body", &self.body)
            .finish()
    }
}
impl crate::Debug for syn::ExprGroup {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprGroup")
            .field("attrs", &self.attrs)
            .field("group_token", &self.group_token)
            .field("expr", &self.expr)
            .finish()
    }
}
impl crate::Debug for syn::ExprIf {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprIf")
            .field("attrs", &self.attrs)
            .field("if_token", &self.if_token)
            .field("cond", &self.cond)
            .field("then_branch", &self.then_branch)
            .field("else_branch", &self.else_branch)
            .finish()
    }
}
impl crate::Debug for syn::ExprIndex {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprIndex")
            .field("attrs", &self.attrs)
            .field("expr", &self.expr)
            .field("bracket_token", &self.bracket_token)
            .field("index", &self.index)
            .finish()
    }
}
impl crate::Debug for syn::ExprLet {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprLet")
            .field("attrs", &self.attrs)
            .field("let_token", &self.let_token)
            .field("pat", &self.pat)
            .field("eq_token", &self.eq_token)
            .field("expr", &self.expr)
            .finish()
    }
}
impl crate::Debug for syn::ExprLit {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprLit")
            .field("attrs", &self.attrs)
            .field("lit", &self.lit)
            .finish()
    }
}
impl crate::Debug for syn::ExprLoop {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprLoop")
            .field("attrs", &self.attrs)
            .field("label", &self.label)
            .field("loop_token", &self.loop_token)
            .field("body", &self.body)
            .finish()
    }
}
impl crate::Debug for syn::ExprMacro {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprMacro")
            .field("attrs", &self.attrs)
            .field("mac", &self.mac)
            .finish()
    }
}
impl crate::Debug for syn::ExprMatch {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprMatch")
            .field("attrs", &self.attrs)
            .field("match_token", &self.match_token)
            .field("expr", &self.expr)
            .field("brace_token", &self.brace_token)
            .field("arms", &self.arms)
            .finish()
    }
}
impl crate::Debug for syn::ExprMethodCall {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprMethodCall")
            .field("attrs", &self.attrs)
            .field("receiver", &self.receiver)
            .field("dot_token", &self.dot_token)
            .field("method", &self.method)
            .field("turbofish", &self.turbofish)
            .field("paren_token", &self.paren_token)
            .field("args", &self.args)
            .finish()
    }
}
impl crate::Debug for syn::ExprParen {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprParen")
            .field("attrs", &self.attrs)
            .field("paren_token", &self.paren_token)
            .field("expr", &self.expr)
            .finish()
    }
}
impl crate::Debug for syn::ExprPath {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprPath")
            .field("attrs", &self.attrs)
            .field("qself", &self.qself)
            .field("path", &self.path)
            .finish()
    }
}
impl crate::Debug for syn::ExprRange {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprRange")
            .field("attrs", &self.attrs)
            .field("from", &self.from)
            .field("limits", &self.limits)
            .field("to", &self.to)
            .finish()
    }
}
// Skiping syn::ExprReference due to config rule ExprReference
impl crate::Debug for syn::ExprRepeat {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprRepeat")
            .field("attrs", &self.attrs)
            .field("bracket_token", &self.bracket_token)
            .field("expr", &self.expr)
            .field("semi_token", &self.semi_token)
            .field("len", &self.len)
            .finish()
    }
}
impl crate::Debug for syn::ExprReturn {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprReturn")
            .field("attrs", &self.attrs)
            .field("return_token", &self.return_token)
            .field("expr", &self.expr)
            .finish()
    }
}
impl crate::Debug for syn::ExprStruct {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprStruct")
            .field("attrs", &self.attrs)
            .field("path", &self.path)
            .field("brace_token", &self.brace_token)
            .field("fields", &self.fields)
            .field("dot2_token", &self.dot2_token)
            .field("rest", &self.rest)
            .finish()
    }
}
impl crate::Debug for syn::ExprTry {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprTry")
            .field("attrs", &self.attrs)
            .field("expr", &self.expr)
            .field("question_token", &self.question_token)
            .finish()
    }
}
impl crate::Debug for syn::ExprTryBlock {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprTryBlock")
            .field("attrs", &self.attrs)
            .field("try_token", &self.try_token)
            .field("block", &self.block)
            .finish()
    }
}
impl crate::Debug for syn::ExprTuple {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprTuple")
            .field("attrs", &self.attrs)
            .field("paren_token", &self.paren_token)
            .field("elems", &self.elems)
            .finish()
    }
}
impl crate::Debug for syn::ExprType {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprType")
            .field("attrs", &self.attrs)
            .field("expr", &self.expr)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .finish()
    }
}
impl crate::Debug for syn::ExprUnary {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprUnary")
            .field("attrs", &self.attrs)
            .field("op", &self.op)
            .field("expr", &self.expr)
            .finish()
    }
}
impl crate::Debug for syn::ExprUnsafe {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprUnsafe")
            .field("attrs", &self.attrs)
            .field("unsafe_token", &self.unsafe_token)
            .field("block", &self.block)
            .finish()
    }
}
impl crate::Debug for syn::ExprWhile {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprWhile")
            .field("attrs", &self.attrs)
            .field("label", &self.label)
            .field("while_token", &self.while_token)
            .field("cond", &self.cond)
            .field("body", &self.body)
            .finish()
    }
}
impl crate::Debug for syn::ExprYield {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprYield")
            .field("attrs", &self.attrs)
            .field("yield_token", &self.yield_token)
            .field("expr", &self.expr)
            .finish()
    }
}
impl crate::Debug for syn::Field {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Field")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .finish()
    }
}
impl crate::Debug for syn::FieldPat {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("FieldPat")
            .field("attrs", &self.attrs)
            .field("member", &self.member)
            .field("colon_token", &self.colon_token)
            .field("pat", &self.pat)
            .finish()
    }
}
impl crate::Debug for syn::FieldValue {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("FieldValue")
            .field("attrs", &self.attrs)
            .field("member", &self.member)
            .field("colon_token", &self.colon_token)
            .field("expr", &self.expr)
            .finish()
    }
}
impl crate::Debug for syn::Fields {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Named(__0) => {
                f.debug_tuple("Named").field(__0).finish();
            }
            Self::Unnamed(__0) => {
                f.debug_tuple("Unnamed").field(__0).finish();
            }
            Self::Unit => {
                f.debug_tuple("Unit").finish();
            }
        }
    }
}
impl crate::Debug for syn::FieldsNamed {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("FieldsNamed")
            .field("brace_token", &self.brace_token)
            .field("named", &self.named)
            .finish()
    }
}
impl crate::Debug for syn::FieldsUnnamed {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("FieldsUnnamed")
            .field("paren_token", &self.paren_token)
            .field("unnamed", &self.unnamed)
            .finish()
    }
}
impl crate::Debug for syn::File {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("File")
            .field("shebang", &self.shebang)
            .field("attrs", &self.attrs)
            .field("items", &self.items)
            .finish()
    }
}
impl crate::Debug for syn::FnArg {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Receiver(__0) => {
                f.debug_tuple("Receiver").field(__0).finish();
            }
            Self::Typed(__0) => {
                f.debug_tuple("Typed").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::ForeignItem {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Fn(__0) => {
                f.debug_tuple("Fn").field(__0).finish();
            }
            Self::Static(__0) => {
                f.debug_tuple("Static").field(__0).finish();
            }
            Self::Type(__0) => {
                f.debug_tuple("Type").field(__0).finish();
            }
            Self::Macro(__0) => {
                f.debug_tuple("Macro").field(__0).finish();
            }
            Self::Verbatim(__0) => {
                f.debug_tuple("Verbatim").field(__0).finish();
            }
            _ => "???".fmt(f),
        }
    }
}
impl crate::Debug for syn::ForeignItemFn {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ForeignItemFn")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("sig", &self.sig)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::ForeignItemMacro {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ForeignItemMacro")
            .field("attrs", &self.attrs)
            .field("mac", &self.mac)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::ForeignItemStatic {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ForeignItemStatic")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("static_token", &self.static_token)
            .field("mutability", &self.mutability)
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::ForeignItemType {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ForeignItemType")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("type_token", &self.type_token)
            .field("ident", &self.ident)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::GenericArgument {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Lifetime(__0) => {
                f.debug_tuple("Lifetime").field(__0).finish();
            }
            Self::Type(__0) => {
                f.debug_tuple("Type").field(__0).finish();
            }
            Self::Binding(__0) => {
                f.debug_tuple("Binding").field(__0).finish();
            }
            Self::Constraint(__0) => {
                f.debug_tuple("Constraint").field(__0).finish();
            }
            Self::Const(__0) => {
                f.debug_tuple("Const").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::GenericMethodArgument {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Type(__0) => {
                f.debug_tuple("Type").field(__0).finish();
            }
            Self::Const(__0) => {
                f.debug_tuple("Const").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::GenericParam {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Type(__0) => {
                f.debug_tuple("Type").field(__0).finish();
            }
            Self::Lifetime(__0) => {
                f.debug_tuple("Lifetime").field(__0).finish();
            }
            Self::Const(__0) => {
                f.debug_tuple("Const").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::Generics {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Generics")
            .field("lt_token", &self.lt_token)
            .field("params", &self.params)
            .field("gt_token", &self.gt_token)
            .field("where_clause", &self.where_clause)
            .finish()
    }
}
// Skipping syn::ImplGenerics due to hidden fields
impl crate::Debug for syn::ImplItem {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Const(__0) => {
                f.debug_tuple("Const").field(__0).finish();
            }
            Self::Method(__0) => {
                f.debug_tuple("Method").field(__0).finish();
            }
            Self::Type(__0) => {
                f.debug_tuple("Type").field(__0).finish();
            }
            Self::Macro(__0) => {
                f.debug_tuple("Macro").field(__0).finish();
            }
            Self::Verbatim(__0) => {
                f.debug_tuple("Verbatim").field(__0).finish();
            }
            _ => "???".fmt(f),
        }
    }
}
impl crate::Debug for syn::ImplItemConst {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ImplItemConst")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("defaultness", &self.defaultness)
            .field("const_token", &self.const_token)
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .field("eq_token", &self.eq_token)
            .field("expr", &self.expr)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::ImplItemMacro {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ImplItemMacro")
            .field("attrs", &self.attrs)
            .field("mac", &self.mac)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::ImplItemMethod {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ImplItemMethod")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("defaultness", &self.defaultness)
            .field("sig", &self.sig)
            .field("block", &self.block)
            .finish()
    }
}
impl crate::Debug for syn::ImplItemType {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ImplItemType")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("defaultness", &self.defaultness)
            .field("type_token", &self.type_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("eq_token", &self.eq_token)
            .field("ty", &self.ty)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::Index {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Index")
            .field("index", &self.index)
            .field("span", &self.span)
            .finish()
    }
}
impl crate::Debug for syn::Item {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Const(__0) => {
                f.debug_tuple("Const").field(__0).finish();
            }
            Self::Enum(__0) => {
                f.debug_tuple("Enum").field(__0).finish();
            }
            Self::ExternCrate(__0) => {
                f.debug_tuple("ExternCrate").field(__0).finish();
            }
            Self::Fn(__0) => {
                f.debug_tuple("Fn").field(__0).finish();
            }
            Self::ForeignMod(__0) => {
                f.debug_tuple("ForeignMod").field(__0).finish();
            }
            Self::Impl(__0) => {
                f.debug_tuple("Impl").field(__0).finish();
            }
            Self::Macro(__0) => {
                f.debug_tuple("Macro").field(__0).finish();
            }
            Self::Macro2(__0) => {
                f.debug_tuple("Macro2").field(__0).finish();
            }
            Self::Mod(__0) => {
                f.debug_tuple("Mod").field(__0).finish();
            }
            Self::Static(__0) => {
                f.debug_tuple("Static").field(__0).finish();
            }
            Self::Struct(__0) => {
                f.debug_tuple("Struct").field(__0).finish();
            }
            Self::Trait(__0) => {
                f.debug_tuple("Trait").field(__0).finish();
            }
            Self::TraitAlias(__0) => {
                f.debug_tuple("TraitAlias").field(__0).finish();
            }
            Self::Type(__0) => {
                f.debug_tuple("Type").field(__0).finish();
            }
            Self::Union(__0) => {
                f.debug_tuple("Union").field(__0).finish();
            }
            Self::Use(__0) => {
                f.debug_tuple("Use").field(__0).finish();
            }
            Self::Verbatim(__0) => {
                f.debug_tuple("Verbatim").field(__0).finish();
            }
            _ => "???".fmt(f),
        }
    }
}
impl crate::Debug for syn::ItemConst {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemConst")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("const_token", &self.const_token)
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .field("eq_token", &self.eq_token)
            .field("expr", &self.expr)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::ItemEnum {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemEnum")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("enum_token", &self.enum_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("brace_token", &self.brace_token)
            .field("variants", &self.variants)
            .finish()
    }
}
impl crate::Debug for syn::ItemExternCrate {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemExternCrate")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("extern_token", &self.extern_token)
            .field("crate_token", &self.crate_token)
            .field("ident", &self.ident)
            .field("rename", &self.rename)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::ItemFn {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemFn")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("sig", &self.sig)
            .field("block", &self.block)
            .finish()
    }
}
impl crate::Debug for syn::ItemForeignMod {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemForeignMod")
            .field("attrs", &self.attrs)
            .field("abi", &self.abi)
            .field("brace_token", &self.brace_token)
            .field("items", &self.items)
            .finish()
    }
}
impl crate::Debug for syn::ItemImpl {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemImpl")
            .field("attrs", &self.attrs)
            .field("defaultness", &self.defaultness)
            .field("unsafety", &self.unsafety)
            .field("impl_token", &self.impl_token)
            .field("generics", &self.generics)
            .field("trait_", &self.trait_)
            .field("self_ty", &self.self_ty)
            .field("brace_token", &self.brace_token)
            .field("items", &self.items)
            .finish()
    }
}
impl crate::Debug for syn::ItemMacro {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemMacro")
            .field("attrs", &self.attrs)
            .field("ident", &self.ident)
            .field("mac", &self.mac)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::ItemMacro2 {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemMacro2")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("macro_token", &self.macro_token)
            .field("ident", &self.ident)
            .field("rules", &self.rules)
            .finish()
    }
}
impl crate::Debug for syn::ItemMod {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemMod")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("mod_token", &self.mod_token)
            .field("ident", &self.ident)
            .field("content", &self.content)
            .field("semi", &self.semi)
            .finish()
    }
}
impl crate::Debug for syn::ItemStatic {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemStatic")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("static_token", &self.static_token)
            .field("mutability", &self.mutability)
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .field("eq_token", &self.eq_token)
            .field("expr", &self.expr)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::ItemStruct {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemStruct")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("struct_token", &self.struct_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("fields", &self.fields)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::ItemTrait {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemTrait")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("unsafety", &self.unsafety)
            .field("auto_token", &self.auto_token)
            .field("trait_token", &self.trait_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("colon_token", &self.colon_token)
            .field("supertraits", &self.supertraits)
            .field("brace_token", &self.brace_token)
            .field("items", &self.items)
            .finish()
    }
}
impl crate::Debug for syn::ItemTraitAlias {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemTraitAlias")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("trait_token", &self.trait_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("eq_token", &self.eq_token)
            .field("bounds", &self.bounds)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::ItemType {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemType")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("type_token", &self.type_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("eq_token", &self.eq_token)
            .field("ty", &self.ty)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::ItemUnion {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemUnion")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("union_token", &self.union_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("fields", &self.fields)
            .finish()
    }
}
impl crate::Debug for syn::ItemUse {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemUse")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("use_token", &self.use_token)
            .field("leading_colon", &self.leading_colon)
            .field("tree", &self.tree)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::Label {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Label")
            .field("name", &self.name)
            .field("colon_token", &self.colon_token)
            .finish()
    }
}
impl crate::Debug for syn::Lifetime {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Lifetime")
            .field("apostrophe", &self.apostrophe)
            .field("ident", &self.ident)
            .finish()
    }
}
impl crate::Debug for syn::LifetimeDef {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("LifetimeDef")
            .field("attrs", &self.attrs)
            .field("lifetime", &self.lifetime)
            .field("colon_token", &self.colon_token)
            .field("bounds", &self.bounds)
            .finish()
    }
}
impl crate::Debug for syn::Lit {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Str(__0) => {
                f.debug_tuple("Str").field(__0).finish();
            }
            Self::ByteStr(__0) => {
                f.debug_tuple("ByteStr").field(__0).finish();
            }
            Self::Byte(__0) => {
                f.debug_tuple("Byte").field(__0).finish();
            }
            Self::Char(__0) => {
                f.debug_tuple("Char").field(__0).finish();
            }
            Self::Int(__0) => {
                f.debug_tuple("Int").field(__0).finish();
            }
            Self::Float(__0) => {
                f.debug_tuple("Float").field(__0).finish();
            }
            Self::Bool(__0) => {
                f.debug_tuple("Bool").field(__0).finish();
            }
            Self::Verbatim(__0) => {
                f.debug_tuple("Verbatim").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::LitBool {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("LitBool")
            .field("value", &self.value)
            .field("span", &self.span)
            .finish()
    }
}
// Skipping syn::LitByte due to hidden fields
// Skipping syn::LitByteStr due to hidden fields
// Skipping syn::LitChar due to hidden fields
// Skipping syn::LitFloat due to hidden fields
// Skipping syn::LitInt due to hidden fields
// Skipping syn::LitStr due to hidden fields
impl crate::Debug for syn::Local {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Local")
            .field("attrs", &self.attrs)
            .field("let_token", &self.let_token)
            .field("pat", &self.pat)
            .field("init", &self.init)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::Macro {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Macro")
            .field("path", &self.path)
            .field("bang_token", &self.bang_token)
            .field("delimiter", &self.delimiter)
            .field("tokens", &self.tokens)
            .finish()
    }
}
impl crate::Debug for syn::MacroDelimiter {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Paren(__0) => {
                f.debug_tuple("Paren").field(__0).finish();
            }
            Self::Brace(__0) => {
                f.debug_tuple("Brace").field(__0).finish();
            }
            Self::Bracket(__0) => {
                f.debug_tuple("Bracket").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::Member {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Named(__0) => {
                f.debug_tuple("Named").field(__0).finish();
            }
            Self::Unnamed(__0) => {
                f.debug_tuple("Unnamed").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::Meta {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Path(__0) => {
                f.debug_tuple("Path").field(__0).finish();
            }
            Self::List(__0) => {
                f.debug_tuple("List").field(__0).finish();
            }
            Self::NameValue(__0) => {
                f.debug_tuple("NameValue").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::MetaList {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("MetaList")
            .field("path", &self.path)
            .field("paren_token", &self.paren_token)
            .field("nested", &self.nested)
            .finish()
    }
}
impl crate::Debug for syn::MetaNameValue {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("MetaNameValue")
            .field("path", &self.path)
            .field("eq_token", &self.eq_token)
            .field("lit", &self.lit)
            .finish()
    }
}
impl crate::Debug for syn::MethodTurbofish {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("MethodTurbofish")
            .field("colon2_token", &self.colon2_token)
            .field("lt_token", &self.lt_token)
            .field("args", &self.args)
            .field("gt_token", &self.gt_token)
            .finish()
    }
}
impl crate::Debug for syn::NestedMeta {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Meta(__0) => {
                f.debug_tuple("Meta").field(__0).finish();
            }
            Self::Lit(__0) => {
                f.debug_tuple("Lit").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::ParenthesizedGenericArguments {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ParenthesizedGenericArguments")
            .field("paren_token", &self.paren_token)
            .field("inputs", &self.inputs)
            .field("output", &self.output)
            .finish()
    }
}
impl crate::Debug for syn::Pat {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Box(__0) => {
                f.debug_tuple("Box").field(__0).finish();
            }
            Self::Ident(__0) => {
                f.debug_tuple("Ident").field(__0).finish();
            }
            Self::Lit(__0) => {
                f.debug_tuple("Lit").field(__0).finish();
            }
            Self::Macro(__0) => {
                f.debug_tuple("Macro").field(__0).finish();
            }
            Self::Or(__0) => {
                f.debug_tuple("Or").field(__0).finish();
            }
            Self::Path(__0) => {
                f.debug_tuple("Path").field(__0).finish();
            }
            Self::Range(__0) => {
                f.debug_tuple("Range").field(__0).finish();
            }
            Self::Reference(__0) => {
                f.debug_tuple("Reference").field(__0).finish();
            }
            Self::Rest(__0) => {
                f.debug_tuple("Rest").field(__0).finish();
            }
            Self::Slice(__0) => {
                f.debug_tuple("Slice").field(__0).finish();
            }
            Self::Struct(__0) => {
                f.debug_tuple("Struct").field(__0).finish();
            }
            Self::Tuple(__0) => {
                f.debug_tuple("Tuple").field(__0).finish();
            }
            Self::TupleStruct(__0) => {
                f.debug_tuple("TupleStruct").field(__0).finish();
            }
            Self::Type(__0) => {
                f.debug_tuple("Type").field(__0).finish();
            }
            Self::Verbatim(__0) => {
                f.debug_tuple("Verbatim").field(__0).finish();
            }
            Self::Wild(__0) => {
                f.debug_tuple("Wild").field(__0).finish();
            }
            _ => "???".fmt(f),
        }
    }
}
impl crate::Debug for syn::PatBox {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatBox")
            .field("attrs", &self.attrs)
            .field("box_token", &self.box_token)
            .field("pat", &self.pat)
            .finish()
    }
}
impl crate::Debug for syn::PatIdent {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatIdent")
            .field("attrs", &self.attrs)
            .field("by_ref", &self.by_ref)
            .field("mutability", &self.mutability)
            .field("ident", &self.ident)
            .field("subpat", &self.subpat)
            .finish()
    }
}
impl crate::Debug for syn::PatLit {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatLit")
            .field("attrs", &self.attrs)
            .field("expr", &self.expr)
            .finish()
    }
}
impl crate::Debug for syn::PatMacro {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatMacro")
            .field("attrs", &self.attrs)
            .field("mac", &self.mac)
            .finish()
    }
}
impl crate::Debug for syn::PatOr {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatOr")
            .field("attrs", &self.attrs)
            .field("leading_vert", &self.leading_vert)
            .field("cases", &self.cases)
            .finish()
    }
}
impl crate::Debug for syn::PatPath {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatPath")
            .field("attrs", &self.attrs)
            .field("qself", &self.qself)
            .field("path", &self.path)
            .finish()
    }
}
impl crate::Debug for syn::PatRange {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatRange")
            .field("attrs", &self.attrs)
            .field("lo", &self.lo)
            .field("limits", &self.limits)
            .field("hi", &self.hi)
            .finish()
    }
}
impl crate::Debug for syn::PatReference {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatReference")
            .field("attrs", &self.attrs)
            .field("and_token", &self.and_token)
            .field("mutability", &self.mutability)
            .field("pat", &self.pat)
            .finish()
    }
}
impl crate::Debug for syn::PatRest {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatRest")
            .field("attrs", &self.attrs)
            .field("dot2_token", &self.dot2_token)
            .finish()
    }
}
impl crate::Debug for syn::PatSlice {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatSlice")
            .field("attrs", &self.attrs)
            .field("bracket_token", &self.bracket_token)
            .field("elems", &self.elems)
            .finish()
    }
}
impl crate::Debug for syn::PatStruct {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatStruct")
            .field("attrs", &self.attrs)
            .field("path", &self.path)
            .field("brace_token", &self.brace_token)
            .field("fields", &self.fields)
            .field("dot2_token", &self.dot2_token)
            .finish()
    }
}
impl crate::Debug for syn::PatTuple {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatTuple")
            .field("attrs", &self.attrs)
            .field("paren_token", &self.paren_token)
            .field("elems", &self.elems)
            .finish()
    }
}
impl crate::Debug for syn::PatTupleStruct {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatTupleStruct")
            .field("attrs", &self.attrs)
            .field("path", &self.path)
            .field("pat", &self.pat)
            .finish()
    }
}
impl crate::Debug for syn::PatType {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatType")
            .field("attrs", &self.attrs)
            .field("pat", &self.pat)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .finish()
    }
}
impl crate::Debug for syn::PatWild {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatWild")
            .field("attrs", &self.attrs)
            .field("underscore_token", &self.underscore_token)
            .finish()
    }
}
impl crate::Debug for syn::Path {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Path")
            .field("leading_colon", &self.leading_colon)
            .field("segments", &self.segments)
            .finish()
    }
}
impl crate::Debug for syn::PathArguments {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::None => {
                f.debug_tuple("None").finish();
            }
            Self::AngleBracketed(__0) => {
                f.debug_tuple("AngleBracketed").field(__0).finish();
            }
            Self::Parenthesized(__0) => {
                f.debug_tuple("Parenthesized").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::PathSegment {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PathSegment")
            .field("ident", &self.ident)
            .field("arguments", &self.arguments)
            .finish()
    }
}
impl crate::Debug for syn::PredicateEq {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PredicateEq")
            .field("lhs_ty", &self.lhs_ty)
            .field("eq_token", &self.eq_token)
            .field("rhs_ty", &self.rhs_ty)
            .finish()
    }
}
impl crate::Debug for syn::PredicateLifetime {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PredicateLifetime")
            .field("lifetime", &self.lifetime)
            .field("colon_token", &self.colon_token)
            .field("bounds", &self.bounds)
            .finish()
    }
}
impl crate::Debug for syn::PredicateType {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PredicateType")
            .field("lifetimes", &self.lifetimes)
            .field("bounded_ty", &self.bounded_ty)
            .field("colon_token", &self.colon_token)
            .field("bounds", &self.bounds)
            .finish()
    }
}
impl crate::Debug for syn::QSelf {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("QSelf")
            .field("lt_token", &self.lt_token)
            .field("ty", &self.ty)
            .field("position", &self.position)
            .field("as_token", &self.as_token)
            .field("gt_token", &self.gt_token)
            .finish()
    }
}
impl crate::Debug for syn::RangeLimits {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::HalfOpen(__0) => {
                f.debug_tuple("HalfOpen").field(__0).finish();
            }
            Self::Closed(__0) => {
                f.debug_tuple("Closed").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::Receiver {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Receiver")
            .field("attrs", &self.attrs)
            .field("reference", &self.reference)
            .field("mutability", &self.mutability)
            .field("self_token", &self.self_token)
            .finish()
    }
}
impl crate::Debug for syn::ReturnType {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Default => {
                f.debug_tuple("Default").finish();
            }
            Self::Type(__0, __1) => {
                f.debug_tuple("Type").field(__0).field(__1).finish();
            }
        }
    }
}
impl crate::Debug for syn::Signature {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Signature")
            .field("constness", &self.constness)
            .field("asyncness", &self.asyncness)
            .field("unsafety", &self.unsafety)
            .field("abi", &self.abi)
            .field("fn_token", &self.fn_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("paren_token", &self.paren_token)
            .field("inputs", &self.inputs)
            .field("variadic", &self.variadic)
            .field("output", &self.output)
            .finish()
    }
}
impl crate::Debug for syn::Stmt {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Local(__0) => {
                f.debug_tuple("Local").field(__0).finish();
            }
            Self::Item(__0) => {
                f.debug_tuple("Item").field(__0).finish();
            }
            Self::Expr(__0) => {
                f.debug_tuple("Expr").field(__0).finish();
            }
            Self::Semi(__0, __1) => {
                f.debug_tuple("Semi").field(__0).field(__1).finish();
            }
        }
    }
}
impl crate::Debug for syn::StrStyle {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Cooked => {
                f.debug_tuple("Cooked").finish();
            }
            Self::Raw(__0) => {
                f.debug_tuple("Raw").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::TraitBound {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TraitBound")
            .field("paren_token", &self.paren_token)
            .field("modifier", &self.modifier)
            .field("lifetimes", &self.lifetimes)
            .field("path", &self.path)
            .finish()
    }
}
impl crate::Debug for syn::TraitBoundModifier {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::None => {
                f.debug_tuple("None").finish();
            }
            Self::Maybe(__0) => {
                f.debug_tuple("Maybe").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::TraitItem {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Const(__0) => {
                f.debug_tuple("Const").field(__0).finish();
            }
            Self::Method(__0) => {
                f.debug_tuple("Method").field(__0).finish();
            }
            Self::Type(__0) => {
                f.debug_tuple("Type").field(__0).finish();
            }
            Self::Macro(__0) => {
                f.debug_tuple("Macro").field(__0).finish();
            }
            Self::Verbatim(__0) => {
                f.debug_tuple("Verbatim").field(__0).finish();
            }
            _ => "???".fmt(f),
        }
    }
}
impl crate::Debug for syn::TraitItemConst {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TraitItemConst")
            .field("attrs", &self.attrs)
            .field("const_token", &self.const_token)
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .field("default", &self.default)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::TraitItemMacro {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TraitItemMacro")
            .field("attrs", &self.attrs)
            .field("mac", &self.mac)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::TraitItemMethod {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TraitItemMethod")
            .field("attrs", &self.attrs)
            .field("sig", &self.sig)
            .field("default", &self.default)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl crate::Debug for syn::TraitItemType {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TraitItemType")
            .field("attrs", &self.attrs)
            .field("type_token", &self.type_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("colon_token", &self.colon_token)
            .field("bounds", &self.bounds)
            .field("default", &self.default)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
// Skipping syn::Turbofish due to hidden fields
impl crate::Debug for syn::Type {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Array(__0) => {
                f.debug_tuple("Array").field(__0).finish();
            }
            Self::BareFn(__0) => {
                f.debug_tuple("BareFn").field(__0).finish();
            }
            Self::Group(__0) => {
                f.debug_tuple("Group").field(__0).finish();
            }
            Self::ImplTrait(__0) => {
                f.debug_tuple("ImplTrait").field(__0).finish();
            }
            Self::Infer(__0) => {
                f.debug_tuple("Infer").field(__0).finish();
            }
            Self::Macro(__0) => {
                f.debug_tuple("Macro").field(__0).finish();
            }
            Self::Never(__0) => {
                f.debug_tuple("Never").field(__0).finish();
            }
            Self::Paren(__0) => {
                f.debug_tuple("Paren").field(__0).finish();
            }
            Self::Path(__0) => {
                f.debug_tuple("Path").field(__0).finish();
            }
            Self::Ptr(__0) => {
                f.debug_tuple("Ptr").field(__0).finish();
            }
            Self::Reference(__0) => {
                f.debug_tuple("Reference").field(__0).finish();
            }
            Self::Slice(__0) => {
                f.debug_tuple("Slice").field(__0).finish();
            }
            Self::TraitObject(__0) => {
                f.debug_tuple("TraitObject").field(__0).finish();
            }
            Self::Tuple(__0) => {
                f.debug_tuple("Tuple").field(__0).finish();
            }
            Self::Verbatim(__0) => {
                f.debug_tuple("Verbatim").field(__0).finish();
            }
            _ => "???".fmt(f),
        }
    }
}
impl crate::Debug for syn::TypeArray {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeArray")
            .field("bracket_token", &self.bracket_token)
            .field("elem", &self.elem)
            .field("semi_token", &self.semi_token)
            .field("len", &self.len)
            .finish()
    }
}
impl crate::Debug for syn::TypeBareFn {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeBareFn")
            .field("lifetimes", &self.lifetimes)
            .field("unsafety", &self.unsafety)
            .field("abi", &self.abi)
            .field("fn_token", &self.fn_token)
            .field("paren_token", &self.paren_token)
            .field("inputs", &self.inputs)
            .field("variadic", &self.variadic)
            .field("output", &self.output)
            .finish()
    }
}
// Skipping syn::TypeGenerics due to hidden fields
impl crate::Debug for syn::TypeGroup {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeGroup")
            .field("group_token", &self.group_token)
            .field("elem", &self.elem)
            .finish()
    }
}
impl crate::Debug for syn::TypeImplTrait {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeImplTrait")
            .field("impl_token", &self.impl_token)
            .field("bounds", &self.bounds)
            .finish()
    }
}
impl crate::Debug for syn::TypeInfer {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeInfer")
            .field("underscore_token", &self.underscore_token)
            .finish()
    }
}
impl crate::Debug for syn::TypeMacro {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeMacro").field("mac", &self.mac).finish()
    }
}
impl crate::Debug for syn::TypeNever {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeNever")
            .field("bang_token", &self.bang_token)
            .finish()
    }
}
impl crate::Debug for syn::TypeParam {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeParam")
            .field("attrs", &self.attrs)
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("bounds", &self.bounds)
            .field("eq_token", &self.eq_token)
            .field("default", &self.default)
            .finish()
    }
}
impl crate::Debug for syn::TypeParamBound {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Trait(__0) => {
                f.debug_tuple("Trait").field(__0).finish();
            }
            Self::Lifetime(__0) => {
                f.debug_tuple("Lifetime").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::TypeParen {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeParen")
            .field("paren_token", &self.paren_token)
            .field("elem", &self.elem)
            .finish()
    }
}
impl crate::Debug for syn::TypePath {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypePath")
            .field("qself", &self.qself)
            .field("path", &self.path)
            .finish()
    }
}
impl crate::Debug for syn::TypePtr {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypePtr")
            .field("star_token", &self.star_token)
            .field("const_token", &self.const_token)
            .field("mutability", &self.mutability)
            .field("elem", &self.elem)
            .finish()
    }
}
impl crate::Debug for syn::TypeReference {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeReference")
            .field("and_token", &self.and_token)
            .field("lifetime", &self.lifetime)
            .field("mutability", &self.mutability)
            .field("elem", &self.elem)
            .finish()
    }
}
impl crate::Debug for syn::TypeSlice {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeSlice")
            .field("bracket_token", &self.bracket_token)
            .field("elem", &self.elem)
            .finish()
    }
}
impl crate::Debug for syn::TypeTraitObject {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeTraitObject")
            .field("dyn_token", &self.dyn_token)
            .field("bounds", &self.bounds)
            .finish()
    }
}
impl crate::Debug for syn::TypeTuple {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeTuple")
            .field("paren_token", &self.paren_token)
            .field("elems", &self.elems)
            .finish()
    }
}
impl crate::Debug for syn::UnOp {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Deref(__0) => {
                f.debug_tuple("Deref").field(__0).finish();
            }
            Self::Not(__0) => {
                f.debug_tuple("Not").field(__0).finish();
            }
            Self::Neg(__0) => {
                f.debug_tuple("Neg").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::UseGlob {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("UseGlob")
            .field("star_token", &self.star_token)
            .finish()
    }
}
impl crate::Debug for syn::UseGroup {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("UseGroup")
            .field("brace_token", &self.brace_token)
            .field("items", &self.items)
            .finish()
    }
}
impl crate::Debug for syn::UseName {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("UseName")
            .field("ident", &self.ident)
            .finish()
    }
}
impl crate::Debug for syn::UsePath {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("UsePath")
            .field("ident", &self.ident)
            .field("colon2_token", &self.colon2_token)
            .field("tree", &self.tree)
            .finish()
    }
}
impl crate::Debug for syn::UseRename {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("UseRename")
            .field("ident", &self.ident)
            .field("as_token", &self.as_token)
            .field("rename", &self.rename)
            .finish()
    }
}
impl crate::Debug for syn::UseTree {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Path(__0) => {
                f.debug_tuple("Path").field(__0).finish();
            }
            Self::Name(__0) => {
                f.debug_tuple("Name").field(__0).finish();
            }
            Self::Rename(__0) => {
                f.debug_tuple("Rename").field(__0).finish();
            }
            Self::Glob(__0) => {
                f.debug_tuple("Glob").field(__0).finish();
            }
            Self::Group(__0) => {
                f.debug_tuple("Group").field(__0).finish();
            }
        }
    }
}
impl crate::Debug for syn::Variadic {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Variadic")
            .field("attrs", &self.attrs)
            .field("dots", &self.dots)
            .finish()
    }
}
impl crate::Debug for syn::Variant {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Variant")
            .field("attrs", &self.attrs)
            .field("ident", &self.ident)
            .field("fields", &self.fields)
            .field("discriminant", &self.discriminant)
            .finish()
    }
}
impl crate::Debug for syn::VisCrate {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("VisCrate")
            .field("crate_token", &self.crate_token)
            .finish()
    }
}
impl crate::Debug for syn::VisPublic {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("VisPublic")
            .field("pub_token", &self.pub_token)
            .finish()
    }
}
impl crate::Debug for syn::VisRestricted {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("VisRestricted")
            .field("pub_token", &self.pub_token)
            .field("paren_token", &self.paren_token)
            .field("in_token", &self.in_token)
            .field("path", &self.path)
            .finish()
    }
}
impl crate::Debug for syn::Visibility {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Public(__0) => {
                f.debug_tuple("Public").field(__0).finish();
            }
            Self::Crate(__0) => {
                f.debug_tuple("Crate").field(__0).finish();
            }
            Self::Restricted(__0) => {
                f.debug_tuple("Restricted").field(__0).finish();
            }
            Self::Inherited => {
                f.debug_tuple("Inherited").finish();
            }
        }
    }
}
impl crate::Debug for syn::WhereClause {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("WhereClause")
            .field("where_token", &self.where_token)
            .field("predicates", &self.predicates)
            .finish()
    }
}
impl crate::Debug for syn::WherePredicate {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Type(__0) => {
                f.debug_tuple("Type").field(__0).finish();
            }
            Self::Lifetime(__0) => {
                f.debug_tuple("Lifetime").field(__0).finish();
            }
            Self::Eq(__0) => {
                f.debug_tuple("Eq").field(__0).finish();
            }
        }
    }
}
// Skipping syn::buffer::Cursor due to hidden fields
// Skipping syn::buffer::TokenBuffer due to hidden fields
// Skipping syn::parse::Error due to hidden fields
// Skipping syn::parse::Lookahead1 due to hidden fields
impl crate::Debug for syn::parse::Nothing {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Nothing").finish()
    }
}
// Skipping syn::parse::ParseBuffer due to hidden fields
// Skipping syn::parse::StepCursor due to hidden fields
// Skipping syn::punctuated::IntoIter due to hidden fields
// Skipping syn::punctuated::IntoPairs due to hidden fields
// Skipping syn::punctuated::Iter due to hidden fields
// Skipping syn::punctuated::IterMut due to hidden fields
impl<T, P> crate::Debug for syn::punctuated::Pair<T, P>
where
    T: crate::Debug,
    P: crate::Debug,
{
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            Self::Punctuated(__0, __1) => {
                f.debug_tuple("Punctuated").field(__0).field(__1).finish();
            }
            Self::End(__0) => {
                f.debug_tuple("End").field(__0).finish();
            }
        }
    }
}
// Skipping syn::punctuated::Pairs due to hidden fields
// Skipping syn::punctuated::PairsMut due to hidden fields
// Skipping syn::punctuated::Punctuated due to hidden fields
// Skiping syn::token::Abstract due to config rule token::*
// Skiping syn::token::Add due to config rule token::*
// Skiping syn::token::AddEq due to config rule token::*
// Skiping syn::token::And due to config rule token::*
// Skiping syn::token::AndAnd due to config rule token::*
// Skiping syn::token::AndEq due to config rule token::*
// Skiping syn::token::As due to config rule token::*
// Skiping syn::token::Async due to config rule token::*
// Skiping syn::token::At due to config rule token::*
// Skiping syn::token::Auto due to config rule token::*
// Skiping syn::token::Await due to config rule token::*
// Skiping syn::token::Bang due to config rule token::*
// Skiping syn::token::Become due to config rule token::*
// Skiping syn::token::Box due to config rule token::*
// Skiping syn::token::Brace due to config rule token::*
// Skiping syn::token::Bracket due to config rule token::*
// Skiping syn::token::Break due to config rule token::*
// Skiping syn::token::Caret due to config rule token::*
// Skiping syn::token::CaretEq due to config rule token::*
// Skiping syn::token::Colon due to config rule token::*
// Skiping syn::token::Colon2 due to config rule token::*
// Skiping syn::token::Comma due to config rule token::*
// Skiping syn::token::Const due to config rule token::*
// Skiping syn::token::Continue due to config rule token::*
// Skiping syn::token::Crate due to config rule token::*
// Skiping syn::token::Default due to config rule token::*
// Skiping syn::token::Div due to config rule token::*
// Skiping syn::token::DivEq due to config rule token::*
// Skiping syn::token::Do due to config rule token::*
// Skiping syn::token::Dollar due to config rule token::*
// Skiping syn::token::Dot due to config rule token::*
// Skiping syn::token::Dot2 due to config rule token::*
// Skiping syn::token::Dot3 due to config rule token::*
// Skiping syn::token::DotDotEq due to config rule token::*
// Skiping syn::token::Dyn due to config rule token::*
// Skiping syn::token::Else due to config rule token::*
// Skiping syn::token::Enum due to config rule token::*
// Skiping syn::token::Eq due to config rule token::*
// Skiping syn::token::EqEq due to config rule token::*
// Skiping syn::token::Extern due to config rule token::*
// Skiping syn::token::FatArrow due to config rule token::*
// Skiping syn::token::Final due to config rule token::*
// Skiping syn::token::Fn due to config rule token::*
// Skiping syn::token::For due to config rule token::*
// Skiping syn::token::Ge due to config rule token::*
// Skiping syn::token::Group due to config rule token::*
// Skiping syn::token::Gt due to config rule token::*
// Skiping syn::token::If due to config rule token::*
// Skiping syn::token::Impl due to config rule token::*
// Skiping syn::token::In due to config rule token::*
// Skiping syn::token::LArrow due to config rule token::*
// Skiping syn::token::Le due to config rule token::*
// Skiping syn::token::Let due to config rule token::*
// Skiping syn::token::Loop due to config rule token::*
// Skiping syn::token::Lt due to config rule token::*
// Skiping syn::token::Macro due to config rule token::*
// Skiping syn::token::Match due to config rule token::*
// Skiping syn::token::Mod due to config rule token::*
// Skiping syn::token::Move due to config rule token::*
// Skiping syn::token::MulEq due to config rule token::*
// Skiping syn::token::Mut due to config rule token::*
// Skiping syn::token::Ne due to config rule token::*
// Skiping syn::token::Or due to config rule token::*
// Skiping syn::token::OrEq due to config rule token::*
// Skiping syn::token::OrOr due to config rule token::*
// Skiping syn::token::Override due to config rule token::*
// Skiping syn::token::Paren due to config rule token::*
// Skiping syn::token::Pound due to config rule token::*
// Skiping syn::token::Priv due to config rule token::*
// Skiping syn::token::Pub due to config rule token::*
// Skiping syn::token::Question due to config rule token::*
// Skiping syn::token::RArrow due to config rule token::*
// Skiping syn::token::Ref due to config rule token::*
// Skiping syn::token::Rem due to config rule token::*
// Skiping syn::token::RemEq due to config rule token::*
// Skiping syn::token::Return due to config rule token::*
// Skiping syn::token::SelfType due to config rule token::*
// Skiping syn::token::SelfValue due to config rule token::*
// Skiping syn::token::Semi due to config rule token::*
// Skiping syn::token::Shl due to config rule token::*
// Skiping syn::token::ShlEq due to config rule token::*
// Skiping syn::token::Shr due to config rule token::*
// Skiping syn::token::ShrEq due to config rule token::*
// Skiping syn::token::Star due to config rule token::*
// Skiping syn::token::Static due to config rule token::*
// Skiping syn::token::Struct due to config rule token::*
// Skiping syn::token::Sub due to config rule token::*
// Skiping syn::token::SubEq due to config rule token::*
// Skiping syn::token::Super due to config rule token::*
// Skiping syn::token::Tilde due to config rule token::*
// Skiping syn::token::Trait due to config rule token::*
// Skiping syn::token::Try due to config rule token::*
// Skiping syn::token::Type due to config rule token::*
// Skiping syn::token::Typeof due to config rule token::*
// Skiping syn::token::Underscore due to config rule token::*
// Skiping syn::token::Union due to config rule token::*
// Skiping syn::token::Unsafe due to config rule token::*
// Skiping syn::token::Unsized due to config rule token::*
// Skiping syn::token::Use due to config rule token::*
// Skiping syn::token::Virtual due to config rule token::*
// Skiping syn::token::Where due to config rule token::*
// Skiping syn::token::While due to config rule token::*
// Skiping syn::token::Yield due to config rule token::*
