// AUTOGENERATED FILE, DO NOT EDIT
//
// Crate Name: `syn`
// Crate Version: `1.0.91`
impl<> crate::Debug for syn::Abi<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Abi")
            .field("extern_token", &self.extern_token)
            .field("name", &self.name)
            .finish()
    }
}
// Skiping syn::token::Abstract due to config rule token::*
// Skiping syn::token::Add due to config rule token::*
// Skiping syn::token::AddEq due to config rule token::*
// Skiping syn::token::And due to config rule token::*
// Skiping syn::token::AndAnd due to config rule token::*
// Skiping syn::token::AndEq due to config rule token::*
impl<> crate::Debug for syn::AngleBracketedGenericArguments<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("AngleBracketedGenericArguments")
            .field("colon2_token", &self.colon2_token)
            .field("lt_token", &self.lt_token)
            .field("args", &self.args)
            .field("gt_token", &self.gt_token)
            .finish()
    }
}
impl<> crate::Debug for syn::Arm<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Arm")
            .field("attrs", &self.attrs)
            .field("pat", &self.pat)
            .field("guard", &self.guard)
            .field("fat_arrow_token", &self.fat_arrow_token)
            .field("body", &self.body)
            .field("comma", &self.comma)
            .finish()
    }
}
// Skiping syn::token::As due to config rule token::*
// Skiping syn::token::Async due to config rule token::*
// Skiping syn::token::At due to config rule token::*
impl<>  crate::Debug for syn::AttrStyle<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::AttrStyle::Outer => { f.debug_tuple("Outer").finish(); }
            syn::AttrStyle::Inner (__0, ) => { f.debug_tuple("Inner").field(__0).finish(); }
        }
    }
}
impl<> crate::Debug for syn::Attribute<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Attribute")
            .field("pound_token", &self.pound_token)
            .field("style", &self.style)
            .field("bracket_token", &self.bracket_token)
            .field("path", &self.path)
            .field("tokens", &self.tokens)
            .finish()
    }
}
// Skiping syn::token::Auto due to config rule token::*
// Skiping syn::token::Await due to config rule token::*
// Skiping syn::token::Bang due to config rule token::*
impl<> crate::Debug for syn::BareFnArg<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("BareFnArg")
            .field("attrs", &self.attrs)
            .field("name", &self.name)
            .field("ty", &self.ty)
            .finish()
    }
}
// Skiping syn::token::Become due to config rule token::*
impl<>  crate::Debug for syn::BinOp<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::BinOp::Add (__0, ) => { f.debug_tuple("Add").field(__0).finish(); }
            syn::BinOp::Sub (__0, ) => { f.debug_tuple("Sub").field(__0).finish(); }
            syn::BinOp::Mul (__0, ) => { f.debug_tuple("Mul").field(__0).finish(); }
            syn::BinOp::Div (__0, ) => { f.debug_tuple("Div").field(__0).finish(); }
            syn::BinOp::Rem (__0, ) => { f.debug_tuple("Rem").field(__0).finish(); }
            syn::BinOp::And (__0, ) => { f.debug_tuple("And").field(__0).finish(); }
            syn::BinOp::Or (__0, ) => { f.debug_tuple("Or").field(__0).finish(); }
            syn::BinOp::BitXor (__0, ) => { f.debug_tuple("BitXor").field(__0).finish(); }
            syn::BinOp::BitAnd (__0, ) => { f.debug_tuple("BitAnd").field(__0).finish(); }
            syn::BinOp::BitOr (__0, ) => { f.debug_tuple("BitOr").field(__0).finish(); }
            syn::BinOp::Shl (__0, ) => { f.debug_tuple("Shl").field(__0).finish(); }
            syn::BinOp::Shr (__0, ) => { f.debug_tuple("Shr").field(__0).finish(); }
            syn::BinOp::Eq (__0, ) => { f.debug_tuple("Eq").field(__0).finish(); }
            syn::BinOp::Lt (__0, ) => { f.debug_tuple("Lt").field(__0).finish(); }
            syn::BinOp::Le (__0, ) => { f.debug_tuple("Le").field(__0).finish(); }
            syn::BinOp::Ne (__0, ) => { f.debug_tuple("Ne").field(__0).finish(); }
            syn::BinOp::Ge (__0, ) => { f.debug_tuple("Ge").field(__0).finish(); }
            syn::BinOp::Gt (__0, ) => { f.debug_tuple("Gt").field(__0).finish(); }
            syn::BinOp::AddEq (__0, ) => { f.debug_tuple("AddEq").field(__0).finish(); }
            syn::BinOp::SubEq (__0, ) => { f.debug_tuple("SubEq").field(__0).finish(); }
            syn::BinOp::MulEq (__0, ) => { f.debug_tuple("MulEq").field(__0).finish(); }
            syn::BinOp::DivEq (__0, ) => { f.debug_tuple("DivEq").field(__0).finish(); }
            syn::BinOp::RemEq (__0, ) => { f.debug_tuple("RemEq").field(__0).finish(); }
            syn::BinOp::BitXorEq (__0, ) => { f.debug_tuple("BitXorEq").field(__0).finish(); }
            syn::BinOp::BitAndEq (__0, ) => { f.debug_tuple("BitAndEq").field(__0).finish(); }
            syn::BinOp::BitOrEq (__0, ) => { f.debug_tuple("BitOrEq").field(__0).finish(); }
            syn::BinOp::ShlEq (__0, ) => { f.debug_tuple("ShlEq").field(__0).finish(); }
            syn::BinOp::ShrEq (__0, ) => { f.debug_tuple("ShrEq").field(__0).finish(); }
        }
    }
}
impl<> crate::Debug for syn::Binding<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Binding")
            .field("ident", &self.ident)
            .field("eq_token", &self.eq_token)
            .field("ty", &self.ty)
            .finish()
    }
}
impl<> crate::Debug for syn::Block<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Block")
            .field("brace_token", &self.brace_token)
            .field("stmts", &self.stmts)
            .finish()
    }
}
impl<> crate::Debug for syn::BoundLifetimes<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("BoundLifetimes")
            .field("for_token", &self.for_token)
            .field("lt_token", &self.lt_token)
            .field("lifetimes", &self.lifetimes)
            .field("gt_token", &self.gt_token)
            .finish()
    }
}
// Skiping syn::token::Box due to config rule token::*
// Skiping syn::token::Brace due to config rule token::*
// Skiping syn::token::Bracket due to config rule token::*
// Skiping syn::token::Break due to config rule token::*
// Skiping syn::token::Caret due to config rule token::*
// Skiping syn::token::CaretEq due to config rule token::*
// Skiping syn::token::Colon due to config rule token::*
// Skiping syn::token::Colon2 due to config rule token::*
// Skiping syn::token::Comma due to config rule token::*
// Skiping syn::token::Const due to config rule token::*
impl<> crate::Debug for syn::ConstParam<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ConstParam")
            .field("attrs", &self.attrs)
            .field("const_token", &self.const_token)
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .field("eq_token", &self.eq_token)
            .field("default", &self.default)
            .finish()
    }
}
impl<> crate::Debug for syn::Constraint<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Constraint")
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("bounds", &self.bounds)
            .finish()
    }
}
// Skiping syn::token::Continue due to config rule token::*
// Skiping syn::token::Crate due to config rule token::*
// Skipping syn::buffer::Cursor due to hidden fields
impl<>  crate::Debug for syn::Data<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::Data::Struct (__0, ) => { f.debug_tuple("Struct").field(__0).finish(); }
            syn::Data::Enum (__0, ) => { f.debug_tuple("Enum").field(__0).finish(); }
            syn::Data::Union (__0, ) => { f.debug_tuple("Union").field(__0).finish(); }
        }
    }
}
impl<> crate::Debug for syn::DataEnum<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("DataEnum")
            .field("enum_token", &self.enum_token)
            .field("brace_token", &self.brace_token)
            .field("variants", &self.variants)
            .finish()
    }
}
impl<> crate::Debug for syn::DataStruct<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("DataStruct")
            .field("struct_token", &self.struct_token)
            .field("fields", &self.fields)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl<> crate::Debug for syn::DataUnion<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("DataUnion")
            .field("union_token", &self.union_token)
            .field("fields", &self.fields)
            .finish()
    }
}
// Skiping syn::token::Default due to config rule token::*
impl<> crate::Debug for syn::DeriveInput<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("DeriveInput")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("data", &self.data)
            .finish()
    }
}
// Skiping syn::token::Div due to config rule token::*
// Skiping syn::token::DivEq due to config rule token::*
// Skiping syn::token::Do due to config rule token::*
// Skiping syn::token::Dollar due to config rule token::*
// Skiping syn::token::Dot due to config rule token::*
// Skiping syn::token::Dot2 due to config rule token::*
// Skiping syn::token::Dot3 due to config rule token::*
// Skiping syn::token::DotDotEq due to config rule token::*
// Skiping syn::token::Dyn due to config rule token::*
// Skiping syn::token::Else due to config rule token::*
// Skiping syn::token::Enum due to config rule token::*
// Skiping syn::token::Eq due to config rule token::*
// Skiping syn::token::EqEq due to config rule token::*
// Skipping syn::parse::Error due to hidden fields
impl<>  crate::Debug for syn::Expr<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::Expr::Array (__0, ) => { f.debug_tuple("Array").field(__0).finish(); }
            syn::Expr::Assign (__0, ) => { f.debug_tuple("Assign").field(__0).finish(); }
            syn::Expr::AssignOp (__0, ) => { f.debug_tuple("AssignOp").field(__0).finish(); }
            syn::Expr::Async (__0, ) => { f.debug_tuple("Async").field(__0).finish(); }
            syn::Expr::Await (__0, ) => { f.debug_tuple("Await").field(__0).finish(); }
            syn::Expr::Binary (__0, ) => { f.debug_tuple("Binary").field(__0).finish(); }
            syn::Expr::Block (__0, ) => { f.debug_tuple("Block").field(__0).finish(); }
            syn::Expr::Box (__0, ) => { f.debug_tuple("Box").field(__0).finish(); }
            syn::Expr::Break (__0, ) => { f.debug_tuple("Break").field(__0).finish(); }
            syn::Expr::Call (__0, ) => { f.debug_tuple("Call").field(__0).finish(); }
            syn::Expr::Cast (__0, ) => { f.debug_tuple("Cast").field(__0).finish(); }
            syn::Expr::Closure (__0, ) => { f.debug_tuple("Closure").field(__0).finish(); }
            syn::Expr::Continue (__0, ) => { f.debug_tuple("Continue").field(__0).finish(); }
            syn::Expr::Field (__0, ) => { f.debug_tuple("Field").field(__0).finish(); }
            syn::Expr::ForLoop (__0, ) => { f.debug_tuple("ForLoop").field(__0).finish(); }
            syn::Expr::Group (__0, ) => { f.debug_tuple("Group").field(__0).finish(); }
            syn::Expr::If (__0, ) => { f.debug_tuple("If").field(__0).finish(); }
            syn::Expr::Index (__0, ) => { f.debug_tuple("Index").field(__0).finish(); }
            syn::Expr::Let (__0, ) => { f.debug_tuple("Let").field(__0).finish(); }
            syn::Expr::Lit (__0, ) => { f.debug_tuple("Lit").field(__0).finish(); }
            syn::Expr::Loop (__0, ) => { f.debug_tuple("Loop").field(__0).finish(); }
            syn::Expr::Macro (__0, ) => { f.debug_tuple("Macro").field(__0).finish(); }
            syn::Expr::Match (__0, ) => { f.debug_tuple("Match").field(__0).finish(); }
            syn::Expr::MethodCall (__0, ) => { f.debug_tuple("MethodCall").field(__0).finish(); }
            syn::Expr::Paren (__0, ) => { f.debug_tuple("Paren").field(__0).finish(); }
            syn::Expr::Path (__0, ) => { f.debug_tuple("Path").field(__0).finish(); }
            syn::Expr::Range (__0, ) => { f.debug_tuple("Range").field(__0).finish(); }
            syn::Expr::Reference (__0, ) => { f.debug_tuple("Reference").field(__0).finish(); }
            syn::Expr::Repeat (__0, ) => { f.debug_tuple("Repeat").field(__0).finish(); }
            syn::Expr::Return (__0, ) => { f.debug_tuple("Return").field(__0).finish(); }
            syn::Expr::Struct (__0, ) => { f.debug_tuple("Struct").field(__0).finish(); }
            syn::Expr::Try (__0, ) => { f.debug_tuple("Try").field(__0).finish(); }
            syn::Expr::TryBlock (__0, ) => { f.debug_tuple("TryBlock").field(__0).finish(); }
            syn::Expr::Tuple (__0, ) => { f.debug_tuple("Tuple").field(__0).finish(); }
            syn::Expr::Type (__0, ) => { f.debug_tuple("Type").field(__0).finish(); }
            syn::Expr::Unary (__0, ) => { f.debug_tuple("Unary").field(__0).finish(); }
            syn::Expr::Unsafe (__0, ) => { f.debug_tuple("Unsafe").field(__0).finish(); }
            syn::Expr::Verbatim (__0, ) => { f.debug_tuple("Verbatim").field(__0).finish(); }
            syn::Expr::While (__0, ) => { f.debug_tuple("While").field(__0).finish(); }
            syn::Expr::Yield (__0, ) => { f.debug_tuple("Yield").field(__0).finish(); }
            _ => { "???".fmt(f) }
        }
    }
}
impl<> crate::Debug for syn::ExprArray<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprArray")
            .field("attrs", &self.attrs)
            .field("bracket_token", &self.bracket_token)
            .field("elems", &self.elems)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprAssign<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprAssign")
            .field("attrs", &self.attrs)
            .field("left", &self.left)
            .field("eq_token", &self.eq_token)
            .field("right", &self.right)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprAssignOp<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprAssignOp")
            .field("attrs", &self.attrs)
            .field("left", &self.left)
            .field("op", &self.op)
            .field("right", &self.right)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprAsync<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprAsync")
            .field("attrs", &self.attrs)
            .field("async_token", &self.async_token)
            .field("capture", &self.capture)
            .field("block", &self.block)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprAwait<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprAwait")
            .field("attrs", &self.attrs)
            .field("base", &self.base)
            .field("dot_token", &self.dot_token)
            .field("await_token", &self.await_token)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprBinary<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprBinary")
            .field("attrs", &self.attrs)
            .field("left", &self.left)
            .field("op", &self.op)
            .field("right", &self.right)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprBlock<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprBlock")
            .field("attrs", &self.attrs)
            .field("label", &self.label)
            .field("block", &self.block)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprBox<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprBox")
            .field("attrs", &self.attrs)
            .field("box_token", &self.box_token)
            .field("expr", &self.expr)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprBreak<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprBreak")
            .field("attrs", &self.attrs)
            .field("break_token", &self.break_token)
            .field("label", &self.label)
            .field("expr", &self.expr)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprCall<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprCall")
            .field("attrs", &self.attrs)
            .field("func", &self.func)
            .field("paren_token", &self.paren_token)
            .field("args", &self.args)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprCast<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprCast")
            .field("attrs", &self.attrs)
            .field("expr", &self.expr)
            .field("as_token", &self.as_token)
            .field("ty", &self.ty)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprClosure<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprClosure")
            .field("attrs", &self.attrs)
            .field("movability", &self.movability)
            .field("asyncness", &self.asyncness)
            .field("capture", &self.capture)
            .field("or1_token", &self.or1_token)
            .field("inputs", &self.inputs)
            .field("or2_token", &self.or2_token)
            .field("output", &self.output)
            .field("body", &self.body)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprContinue<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprContinue")
            .field("attrs", &self.attrs)
            .field("continue_token", &self.continue_token)
            .field("label", &self.label)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprField<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprField")
            .field("attrs", &self.attrs)
            .field("base", &self.base)
            .field("dot_token", &self.dot_token)
            .field("member", &self.member)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprForLoop<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprForLoop")
            .field("attrs", &self.attrs)
            .field("label", &self.label)
            .field("for_token", &self.for_token)
            .field("pat", &self.pat)
            .field("in_token", &self.in_token)
            .field("expr", &self.expr)
            .field("body", &self.body)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprGroup<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprGroup")
            .field("attrs", &self.attrs)
            .field("group_token", &self.group_token)
            .field("expr", &self.expr)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprIf<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprIf")
            .field("attrs", &self.attrs)
            .field("if_token", &self.if_token)
            .field("cond", &self.cond)
            .field("then_branch", &self.then_branch)
            .field("else_branch", &self.else_branch)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprIndex<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprIndex")
            .field("attrs", &self.attrs)
            .field("expr", &self.expr)
            .field("bracket_token", &self.bracket_token)
            .field("index", &self.index)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprLet<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprLet")
            .field("attrs", &self.attrs)
            .field("let_token", &self.let_token)
            .field("pat", &self.pat)
            .field("eq_token", &self.eq_token)
            .field("expr", &self.expr)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprLit<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprLit")
            .field("attrs", &self.attrs)
            .field("lit", &self.lit)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprLoop<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprLoop")
            .field("attrs", &self.attrs)
            .field("label", &self.label)
            .field("loop_token", &self.loop_token)
            .field("body", &self.body)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprMacro<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprMacro")
            .field("attrs", &self.attrs)
            .field("mac", &self.mac)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprMatch<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprMatch")
            .field("attrs", &self.attrs)
            .field("match_token", &self.match_token)
            .field("expr", &self.expr)
            .field("brace_token", &self.brace_token)
            .field("arms", &self.arms)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprMethodCall<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprMethodCall")
            .field("attrs", &self.attrs)
            .field("receiver", &self.receiver)
            .field("dot_token", &self.dot_token)
            .field("method", &self.method)
            .field("turbofish", &self.turbofish)
            .field("paren_token", &self.paren_token)
            .field("args", &self.args)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprParen<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprParen")
            .field("attrs", &self.attrs)
            .field("paren_token", &self.paren_token)
            .field("expr", &self.expr)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprPath<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprPath")
            .field("attrs", &self.attrs)
            .field("qself", &self.qself)
            .field("path", &self.path)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprRange<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprRange")
            .field("attrs", &self.attrs)
            .field("from", &self.from)
            .field("limits", &self.limits)
            .field("to", &self.to)
            .finish()
    }
}
// Skiping syn::ExprReference due to config rule ExprReference
impl<> crate::Debug for syn::ExprRepeat<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprRepeat")
            .field("attrs", &self.attrs)
            .field("bracket_token", &self.bracket_token)
            .field("expr", &self.expr)
            .field("semi_token", &self.semi_token)
            .field("len", &self.len)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprReturn<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprReturn")
            .field("attrs", &self.attrs)
            .field("return_token", &self.return_token)
            .field("expr", &self.expr)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprStruct<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprStruct")
            .field("attrs", &self.attrs)
            .field("path", &self.path)
            .field("brace_token", &self.brace_token)
            .field("fields", &self.fields)
            .field("dot2_token", &self.dot2_token)
            .field("rest", &self.rest)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprTry<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprTry")
            .field("attrs", &self.attrs)
            .field("expr", &self.expr)
            .field("question_token", &self.question_token)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprTryBlock<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprTryBlock")
            .field("attrs", &self.attrs)
            .field("try_token", &self.try_token)
            .field("block", &self.block)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprTuple<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprTuple")
            .field("attrs", &self.attrs)
            .field("paren_token", &self.paren_token)
            .field("elems", &self.elems)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprType<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprType")
            .field("attrs", &self.attrs)
            .field("expr", &self.expr)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprUnary<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprUnary")
            .field("attrs", &self.attrs)
            .field("op", &self.op)
            .field("expr", &self.expr)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprUnsafe<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprUnsafe")
            .field("attrs", &self.attrs)
            .field("unsafe_token", &self.unsafe_token)
            .field("block", &self.block)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprWhile<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprWhile")
            .field("attrs", &self.attrs)
            .field("label", &self.label)
            .field("while_token", &self.while_token)
            .field("cond", &self.cond)
            .field("body", &self.body)
            .finish()
    }
}
impl<> crate::Debug for syn::ExprYield<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ExprYield")
            .field("attrs", &self.attrs)
            .field("yield_token", &self.yield_token)
            .field("expr", &self.expr)
            .finish()
    }
}
// Skiping syn::token::Extern due to config rule token::*
// Skiping syn::token::FatArrow due to config rule token::*
impl<> crate::Debug for syn::Field<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Field")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .finish()
    }
}
impl<> crate::Debug for syn::FieldPat<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("FieldPat")
            .field("attrs", &self.attrs)
            .field("member", &self.member)
            .field("colon_token", &self.colon_token)
            .field("pat", &self.pat)
            .finish()
    }
}
impl<> crate::Debug for syn::FieldValue<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("FieldValue")
            .field("attrs", &self.attrs)
            .field("member", &self.member)
            .field("colon_token", &self.colon_token)
            .field("expr", &self.expr)
            .finish()
    }
}
impl<>  crate::Debug for syn::Fields<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::Fields::Named (__0, ) => { f.debug_tuple("Named").field(__0).finish(); }
            syn::Fields::Unnamed (__0, ) => { f.debug_tuple("Unnamed").field(__0).finish(); }
            syn::Fields::Unit => { f.debug_tuple("Unit").finish(); }
        }
    }
}
impl<> crate::Debug for syn::FieldsNamed<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("FieldsNamed")
            .field("brace_token", &self.brace_token)
            .field("named", &self.named)
            .finish()
    }
}
impl<> crate::Debug for syn::FieldsUnnamed<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("FieldsUnnamed")
            .field("paren_token", &self.paren_token)
            .field("unnamed", &self.unnamed)
            .finish()
    }
}
impl<> crate::Debug for syn::File<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("File")
            .field("shebang", &self.shebang)
            .field("attrs", &self.attrs)
            .field("items", &self.items)
            .finish()
    }
}
// Skiping syn::token::Final due to config rule token::*
// Skiping syn::token::Fn due to config rule token::*
impl<>  crate::Debug for syn::FnArg<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::FnArg::Receiver (__0, ) => { f.debug_tuple("Receiver").field(__0).finish(); }
            syn::FnArg::Typed (__0, ) => { f.debug_tuple("Typed").field(__0).finish(); }
        }
    }
}
// Skiping syn::token::For due to config rule token::*
impl<>  crate::Debug for syn::ForeignItem<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::ForeignItem::Fn (__0, ) => { f.debug_tuple("Fn").field(__0).finish(); }
            syn::ForeignItem::Static (__0, ) => { f.debug_tuple("Static").field(__0).finish(); }
            syn::ForeignItem::Type (__0, ) => { f.debug_tuple("Type").field(__0).finish(); }
            syn::ForeignItem::Macro (__0, ) => { f.debug_tuple("Macro").field(__0).finish(); }
            syn::ForeignItem::Verbatim (__0, ) => { f.debug_tuple("Verbatim").field(__0).finish(); }
            _ => { "???".fmt(f) }
        }
    }
}
impl<> crate::Debug for syn::ForeignItemFn<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ForeignItemFn")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("sig", &self.sig)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl<> crate::Debug for syn::ForeignItemMacro<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ForeignItemMacro")
            .field("attrs", &self.attrs)
            .field("mac", &self.mac)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl<> crate::Debug for syn::ForeignItemStatic<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ForeignItemStatic")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("static_token", &self.static_token)
            .field("mutability", &self.mutability)
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl<> crate::Debug for syn::ForeignItemType<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ForeignItemType")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("type_token", &self.type_token)
            .field("ident", &self.ident)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
// Skiping syn::token::Ge due to config rule token::*
impl<>  crate::Debug for syn::GenericArgument<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::GenericArgument::Lifetime (__0, ) => { f.debug_tuple("Lifetime").field(__0).finish(); }
            syn::GenericArgument::Type (__0, ) => { f.debug_tuple("Type").field(__0).finish(); }
            syn::GenericArgument::Binding (__0, ) => { f.debug_tuple("Binding").field(__0).finish(); }
            syn::GenericArgument::Constraint (__0, ) => { f.debug_tuple("Constraint").field(__0).finish(); }
            syn::GenericArgument::Const (__0, ) => { f.debug_tuple("Const").field(__0).finish(); }
        }
    }
}
impl<>  crate::Debug for syn::GenericMethodArgument<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::GenericMethodArgument::Type (__0, ) => { f.debug_tuple("Type").field(__0).finish(); }
            syn::GenericMethodArgument::Const (__0, ) => { f.debug_tuple("Const").field(__0).finish(); }
        }
    }
}
impl<>  crate::Debug for syn::GenericParam<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::GenericParam::Type (__0, ) => { f.debug_tuple("Type").field(__0).finish(); }
            syn::GenericParam::Lifetime (__0, ) => { f.debug_tuple("Lifetime").field(__0).finish(); }
            syn::GenericParam::Const (__0, ) => { f.debug_tuple("Const").field(__0).finish(); }
        }
    }
}
impl<> crate::Debug for syn::Generics<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Generics")
            .field("lt_token", &self.lt_token)
            .field("params", &self.params)
            .field("gt_token", &self.gt_token)
            .field("where_clause", &self.where_clause)
            .finish()
    }
}
// Skiping syn::token::Group due to config rule token::*
// Skiping syn::token::Gt due to config rule token::*
// Skiping syn::token::If due to config rule token::*
// Skiping syn::token::Impl due to config rule token::*
// Skipping syn::ImplGenerics due to hidden fields
impl<>  crate::Debug for syn::ImplItem<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::ImplItem::Const (__0, ) => { f.debug_tuple("Const").field(__0).finish(); }
            syn::ImplItem::Method (__0, ) => { f.debug_tuple("Method").field(__0).finish(); }
            syn::ImplItem::Type (__0, ) => { f.debug_tuple("Type").field(__0).finish(); }
            syn::ImplItem::Macro (__0, ) => { f.debug_tuple("Macro").field(__0).finish(); }
            syn::ImplItem::Verbatim (__0, ) => { f.debug_tuple("Verbatim").field(__0).finish(); }
            _ => { "???".fmt(f) }
        }
    }
}
impl<> crate::Debug for syn::ImplItemConst<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ImplItemConst")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("defaultness", &self.defaultness)
            .field("const_token", &self.const_token)
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .field("eq_token", &self.eq_token)
            .field("expr", &self.expr)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl<> crate::Debug for syn::ImplItemMacro<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ImplItemMacro")
            .field("attrs", &self.attrs)
            .field("mac", &self.mac)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl<> crate::Debug for syn::ImplItemMethod<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ImplItemMethod")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("defaultness", &self.defaultness)
            .field("sig", &self.sig)
            .field("block", &self.block)
            .finish()
    }
}
impl<> crate::Debug for syn::ImplItemType<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ImplItemType")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("defaultness", &self.defaultness)
            .field("type_token", &self.type_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("eq_token", &self.eq_token)
            .field("ty", &self.ty)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
// Skiping syn::token::In due to config rule token::*
impl<> crate::Debug for syn::Index<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Index")
            .field("index", &self.index)
            .field("span", &self.span)
            .finish()
    }
}
// Skipping syn::punctuated::IntoIter due to hidden fields
// Skipping syn::punctuated::IntoPairs due to hidden fields
impl<>  crate::Debug for syn::Item<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::Item::Const (__0, ) => { f.debug_tuple("Const").field(__0).finish(); }
            syn::Item::Enum (__0, ) => { f.debug_tuple("Enum").field(__0).finish(); }
            syn::Item::ExternCrate (__0, ) => { f.debug_tuple("ExternCrate").field(__0).finish(); }
            syn::Item::Fn (__0, ) => { f.debug_tuple("Fn").field(__0).finish(); }
            syn::Item::ForeignMod (__0, ) => { f.debug_tuple("ForeignMod").field(__0).finish(); }
            syn::Item::Impl (__0, ) => { f.debug_tuple("Impl").field(__0).finish(); }
            syn::Item::Macro (__0, ) => { f.debug_tuple("Macro").field(__0).finish(); }
            syn::Item::Macro2 (__0, ) => { f.debug_tuple("Macro2").field(__0).finish(); }
            syn::Item::Mod (__0, ) => { f.debug_tuple("Mod").field(__0).finish(); }
            syn::Item::Static (__0, ) => { f.debug_tuple("Static").field(__0).finish(); }
            syn::Item::Struct (__0, ) => { f.debug_tuple("Struct").field(__0).finish(); }
            syn::Item::Trait (__0, ) => { f.debug_tuple("Trait").field(__0).finish(); }
            syn::Item::TraitAlias (__0, ) => { f.debug_tuple("TraitAlias").field(__0).finish(); }
            syn::Item::Type (__0, ) => { f.debug_tuple("Type").field(__0).finish(); }
            syn::Item::Union (__0, ) => { f.debug_tuple("Union").field(__0).finish(); }
            syn::Item::Use (__0, ) => { f.debug_tuple("Use").field(__0).finish(); }
            syn::Item::Verbatim (__0, ) => { f.debug_tuple("Verbatim").field(__0).finish(); }
            _ => { "???".fmt(f) }
        }
    }
}
impl<> crate::Debug for syn::ItemConst<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemConst")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("const_token", &self.const_token)
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .field("eq_token", &self.eq_token)
            .field("expr", &self.expr)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl<> crate::Debug for syn::ItemEnum<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemEnum")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("enum_token", &self.enum_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("brace_token", &self.brace_token)
            .field("variants", &self.variants)
            .finish()
    }
}
impl<> crate::Debug for syn::ItemExternCrate<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemExternCrate")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("extern_token", &self.extern_token)
            .field("crate_token", &self.crate_token)
            .field("ident", &self.ident)
            .field("rename", &self.rename)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl<> crate::Debug for syn::ItemFn<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemFn")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("sig", &self.sig)
            .field("block", &self.block)
            .finish()
    }
}
impl<> crate::Debug for syn::ItemForeignMod<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemForeignMod")
            .field("attrs", &self.attrs)
            .field("abi", &self.abi)
            .field("brace_token", &self.brace_token)
            .field("items", &self.items)
            .finish()
    }
}
impl<> crate::Debug for syn::ItemImpl<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemImpl")
            .field("attrs", &self.attrs)
            .field("defaultness", &self.defaultness)
            .field("unsafety", &self.unsafety)
            .field("impl_token", &self.impl_token)
            .field("generics", &self.generics)
            .field("trait_", &self.trait_)
            .field("self_ty", &self.self_ty)
            .field("brace_token", &self.brace_token)
            .field("items", &self.items)
            .finish()
    }
}
impl<> crate::Debug for syn::ItemMacro<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemMacro")
            .field("attrs", &self.attrs)
            .field("ident", &self.ident)
            .field("mac", &self.mac)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl<> crate::Debug for syn::ItemMacro2<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemMacro2")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("macro_token", &self.macro_token)
            .field("ident", &self.ident)
            .field("rules", &self.rules)
            .finish()
    }
}
impl<> crate::Debug for syn::ItemMod<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemMod")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("mod_token", &self.mod_token)
            .field("ident", &self.ident)
            .field("content", &self.content)
            .field("semi", &self.semi)
            .finish()
    }
}
impl<> crate::Debug for syn::ItemStatic<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemStatic")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("static_token", &self.static_token)
            .field("mutability", &self.mutability)
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .field("eq_token", &self.eq_token)
            .field("expr", &self.expr)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl<> crate::Debug for syn::ItemStruct<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemStruct")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("struct_token", &self.struct_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("fields", &self.fields)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl<> crate::Debug for syn::ItemTrait<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemTrait")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("unsafety", &self.unsafety)
            .field("auto_token", &self.auto_token)
            .field("trait_token", &self.trait_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("colon_token", &self.colon_token)
            .field("supertraits", &self.supertraits)
            .field("brace_token", &self.brace_token)
            .field("items", &self.items)
            .finish()
    }
}
impl<> crate::Debug for syn::ItemTraitAlias<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemTraitAlias")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("trait_token", &self.trait_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("eq_token", &self.eq_token)
            .field("bounds", &self.bounds)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl<> crate::Debug for syn::ItemType<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemType")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("type_token", &self.type_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("eq_token", &self.eq_token)
            .field("ty", &self.ty)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl<> crate::Debug for syn::ItemUnion<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemUnion")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("union_token", &self.union_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("fields", &self.fields)
            .finish()
    }
}
impl<> crate::Debug for syn::ItemUse<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ItemUse")
            .field("attrs", &self.attrs)
            .field("vis", &self.vis)
            .field("use_token", &self.use_token)
            .field("leading_colon", &self.leading_colon)
            .field("tree", &self.tree)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
// Skipping syn::punctuated::Iter due to hidden fields
// Skipping syn::punctuated::IterMut due to hidden fields
// Skiping syn::token::LArrow due to config rule token::*
impl<> crate::Debug for syn::Label<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Label")
            .field("name", &self.name)
            .field("colon_token", &self.colon_token)
            .finish()
    }
}
// Skiping syn::token::Le due to config rule token::*
// Skiping syn::token::Let due to config rule token::*
impl<> crate::Debug for syn::Lifetime<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Lifetime")
            .field("apostrophe", &self.apostrophe)
            .field("ident", &self.ident)
            .finish()
    }
}
impl<> crate::Debug for syn::LifetimeDef<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("LifetimeDef")
            .field("attrs", &self.attrs)
            .field("lifetime", &self.lifetime)
            .field("colon_token", &self.colon_token)
            .field("bounds", &self.bounds)
            .finish()
    }
}
impl<>  crate::Debug for syn::Lit<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::Lit::Str (__0, ) => { f.debug_tuple("Str").field(__0).finish(); }
            syn::Lit::ByteStr (__0, ) => { f.debug_tuple("ByteStr").field(__0).finish(); }
            syn::Lit::Byte (__0, ) => { f.debug_tuple("Byte").field(__0).finish(); }
            syn::Lit::Char (__0, ) => { f.debug_tuple("Char").field(__0).finish(); }
            syn::Lit::Int (__0, ) => { f.debug_tuple("Int").field(__0).finish(); }
            syn::Lit::Float (__0, ) => { f.debug_tuple("Float").field(__0).finish(); }
            syn::Lit::Bool (__0, ) => { f.debug_tuple("Bool").field(__0).finish(); }
            syn::Lit::Verbatim (__0, ) => { f.debug_tuple("Verbatim").field(__0).finish(); }
        }
    }
}
impl<> crate::Debug for syn::LitBool<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("LitBool")
            .field("value", &self.value)
            .field("span", &self.span)
            .finish()
    }
}
// Skipping syn::LitByte due to hidden fields
// Skipping syn::LitByteStr due to hidden fields
// Skipping syn::LitChar due to hidden fields
// Skipping syn::LitFloat due to hidden fields
// Skipping syn::LitInt due to hidden fields
// Skipping syn::LitStr due to hidden fields
impl<> crate::Debug for syn::Local<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Local")
            .field("attrs", &self.attrs)
            .field("let_token", &self.let_token)
            .field("pat", &self.pat)
            .field("init", &self.init)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
// Skipping syn::parse::Lookahead1 due to hidden fields
// Skiping syn::token::Loop due to config rule token::*
// Skiping syn::token::Lt due to config rule token::*
impl<> crate::Debug for syn::Macro<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Macro")
            .field("path", &self.path)
            .field("bang_token", &self.bang_token)
            .field("delimiter", &self.delimiter)
            .field("tokens", &self.tokens)
            .finish()
    }
}
// Skiping syn::token::Macro due to config rule token::*
impl<>  crate::Debug for syn::MacroDelimiter<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::MacroDelimiter::Paren (__0, ) => { f.debug_tuple("Paren").field(__0).finish(); }
            syn::MacroDelimiter::Brace (__0, ) => { f.debug_tuple("Brace").field(__0).finish(); }
            syn::MacroDelimiter::Bracket (__0, ) => { f.debug_tuple("Bracket").field(__0).finish(); }
        }
    }
}
// Skiping syn::token::Match due to config rule token::*
impl<>  crate::Debug for syn::Member<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::Member::Named (__0, ) => { f.debug_tuple("Named").field(__0).finish(); }
            syn::Member::Unnamed (__0, ) => { f.debug_tuple("Unnamed").field(__0).finish(); }
        }
    }
}
impl<>  crate::Debug for syn::Meta<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::Meta::Path (__0, ) => { f.debug_tuple("Path").field(__0).finish(); }
            syn::Meta::List (__0, ) => { f.debug_tuple("List").field(__0).finish(); }
            syn::Meta::NameValue (__0, ) => { f.debug_tuple("NameValue").field(__0).finish(); }
        }
    }
}
impl<> crate::Debug for syn::MetaList<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("MetaList")
            .field("path", &self.path)
            .field("paren_token", &self.paren_token)
            .field("nested", &self.nested)
            .finish()
    }
}
impl<> crate::Debug for syn::MetaNameValue<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("MetaNameValue")
            .field("path", &self.path)
            .field("eq_token", &self.eq_token)
            .field("lit", &self.lit)
            .finish()
    }
}
impl<> crate::Debug for syn::MethodTurbofish<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("MethodTurbofish")
            .field("colon2_token", &self.colon2_token)
            .field("lt_token", &self.lt_token)
            .field("args", &self.args)
            .field("gt_token", &self.gt_token)
            .finish()
    }
}
// Skiping syn::token::Mod due to config rule token::*
// Skiping syn::token::Move due to config rule token::*
// Skiping syn::token::MulEq due to config rule token::*
// Skiping syn::token::Mut due to config rule token::*
// Skiping syn::token::Ne due to config rule token::*
impl<>  crate::Debug for syn::NestedMeta<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::NestedMeta::Meta (__0, ) => { f.debug_tuple("Meta").field(__0).finish(); }
            syn::NestedMeta::Lit (__0, ) => { f.debug_tuple("Lit").field(__0).finish(); }
        }
    }
}
impl<> crate::Debug for syn::parse::Nothing<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Nothing")
            .finish()
    }
}
// Skiping syn::token::Or due to config rule token::*
// Skiping syn::token::OrEq due to config rule token::*
// Skiping syn::token::OrOr due to config rule token::*
// Skiping syn::token::Override due to config rule token::*
impl<T,P>  crate::Debug for syn::punctuated::Pair<T,P> where T : crate::Debug,P : crate::Debug {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::punctuated::Pair::Punctuated (__0, __1, ) => { f.debug_tuple("Punctuated").field(__0).field(__1).finish(); }
            syn::punctuated::Pair::End (__0, ) => { f.debug_tuple("End").field(__0).finish(); }
        }
    }
}
// Skipping syn::punctuated::Pairs due to hidden fields
// Skipping syn::punctuated::PairsMut due to hidden fields
// Skiping syn::token::Paren due to config rule token::*
impl<> crate::Debug for syn::ParenthesizedGenericArguments<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("ParenthesizedGenericArguments")
            .field("paren_token", &self.paren_token)
            .field("inputs", &self.inputs)
            .field("output", &self.output)
            .finish()
    }
}
// Skipping syn::parse::ParseBuffer due to hidden fields
impl<>  crate::Debug for syn::Pat<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::Pat::Box (__0, ) => { f.debug_tuple("Box").field(__0).finish(); }
            syn::Pat::Ident (__0, ) => { f.debug_tuple("Ident").field(__0).finish(); }
            syn::Pat::Lit (__0, ) => { f.debug_tuple("Lit").field(__0).finish(); }
            syn::Pat::Macro (__0, ) => { f.debug_tuple("Macro").field(__0).finish(); }
            syn::Pat::Or (__0, ) => { f.debug_tuple("Or").field(__0).finish(); }
            syn::Pat::Path (__0, ) => { f.debug_tuple("Path").field(__0).finish(); }
            syn::Pat::Range (__0, ) => { f.debug_tuple("Range").field(__0).finish(); }
            syn::Pat::Reference (__0, ) => { f.debug_tuple("Reference").field(__0).finish(); }
            syn::Pat::Rest (__0, ) => { f.debug_tuple("Rest").field(__0).finish(); }
            syn::Pat::Slice (__0, ) => { f.debug_tuple("Slice").field(__0).finish(); }
            syn::Pat::Struct (__0, ) => { f.debug_tuple("Struct").field(__0).finish(); }
            syn::Pat::Tuple (__0, ) => { f.debug_tuple("Tuple").field(__0).finish(); }
            syn::Pat::TupleStruct (__0, ) => { f.debug_tuple("TupleStruct").field(__0).finish(); }
            syn::Pat::Type (__0, ) => { f.debug_tuple("Type").field(__0).finish(); }
            syn::Pat::Verbatim (__0, ) => { f.debug_tuple("Verbatim").field(__0).finish(); }
            syn::Pat::Wild (__0, ) => { f.debug_tuple("Wild").field(__0).finish(); }
            _ => { "???".fmt(f) }
        }
    }
}
impl<> crate::Debug for syn::PatBox<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatBox")
            .field("attrs", &self.attrs)
            .field("box_token", &self.box_token)
            .field("pat", &self.pat)
            .finish()
    }
}
impl<> crate::Debug for syn::PatIdent<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatIdent")
            .field("attrs", &self.attrs)
            .field("by_ref", &self.by_ref)
            .field("mutability", &self.mutability)
            .field("ident", &self.ident)
            .field("subpat", &self.subpat)
            .finish()
    }
}
impl<> crate::Debug for syn::PatLit<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatLit")
            .field("attrs", &self.attrs)
            .field("expr", &self.expr)
            .finish()
    }
}
impl<> crate::Debug for syn::PatMacro<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatMacro")
            .field("attrs", &self.attrs)
            .field("mac", &self.mac)
            .finish()
    }
}
impl<> crate::Debug for syn::PatOr<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatOr")
            .field("attrs", &self.attrs)
            .field("leading_vert", &self.leading_vert)
            .field("cases", &self.cases)
            .finish()
    }
}
impl<> crate::Debug for syn::PatPath<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatPath")
            .field("attrs", &self.attrs)
            .field("qself", &self.qself)
            .field("path", &self.path)
            .finish()
    }
}
impl<> crate::Debug for syn::PatRange<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatRange")
            .field("attrs", &self.attrs)
            .field("lo", &self.lo)
            .field("limits", &self.limits)
            .field("hi", &self.hi)
            .finish()
    }
}
impl<> crate::Debug for syn::PatReference<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatReference")
            .field("attrs", &self.attrs)
            .field("and_token", &self.and_token)
            .field("mutability", &self.mutability)
            .field("pat", &self.pat)
            .finish()
    }
}
impl<> crate::Debug for syn::PatRest<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatRest")
            .field("attrs", &self.attrs)
            .field("dot2_token", &self.dot2_token)
            .finish()
    }
}
impl<> crate::Debug for syn::PatSlice<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatSlice")
            .field("attrs", &self.attrs)
            .field("bracket_token", &self.bracket_token)
            .field("elems", &self.elems)
            .finish()
    }
}
impl<> crate::Debug for syn::PatStruct<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatStruct")
            .field("attrs", &self.attrs)
            .field("path", &self.path)
            .field("brace_token", &self.brace_token)
            .field("fields", &self.fields)
            .field("dot2_token", &self.dot2_token)
            .finish()
    }
}
impl<> crate::Debug for syn::PatTuple<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatTuple")
            .field("attrs", &self.attrs)
            .field("paren_token", &self.paren_token)
            .field("elems", &self.elems)
            .finish()
    }
}
impl<> crate::Debug for syn::PatTupleStruct<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatTupleStruct")
            .field("attrs", &self.attrs)
            .field("path", &self.path)
            .field("pat", &self.pat)
            .finish()
    }
}
impl<> crate::Debug for syn::PatType<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatType")
            .field("attrs", &self.attrs)
            .field("pat", &self.pat)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .finish()
    }
}
impl<> crate::Debug for syn::PatWild<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PatWild")
            .field("attrs", &self.attrs)
            .field("underscore_token", &self.underscore_token)
            .finish()
    }
}
impl<> crate::Debug for syn::Path<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Path")
            .field("leading_colon", &self.leading_colon)
            .field("segments", &self.segments)
            .finish()
    }
}
impl<>  crate::Debug for syn::PathArguments<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::PathArguments::None => { f.debug_tuple("None").finish(); }
            syn::PathArguments::AngleBracketed (__0, ) => { f.debug_tuple("AngleBracketed").field(__0).finish(); }
            syn::PathArguments::Parenthesized (__0, ) => { f.debug_tuple("Parenthesized").field(__0).finish(); }
        }
    }
}
impl<> crate::Debug for syn::PathSegment<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PathSegment")
            .field("ident", &self.ident)
            .field("arguments", &self.arguments)
            .finish()
    }
}
// Skiping syn::token::Pound due to config rule token::*
impl<> crate::Debug for syn::PredicateEq<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PredicateEq")
            .field("lhs_ty", &self.lhs_ty)
            .field("eq_token", &self.eq_token)
            .field("rhs_ty", &self.rhs_ty)
            .finish()
    }
}
impl<> crate::Debug for syn::PredicateLifetime<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PredicateLifetime")
            .field("lifetime", &self.lifetime)
            .field("colon_token", &self.colon_token)
            .field("bounds", &self.bounds)
            .finish()
    }
}
impl<> crate::Debug for syn::PredicateType<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("PredicateType")
            .field("lifetimes", &self.lifetimes)
            .field("bounded_ty", &self.bounded_ty)
            .field("colon_token", &self.colon_token)
            .field("bounds", &self.bounds)
            .finish()
    }
}
// Skiping syn::token::Priv due to config rule token::*
// Skiping syn::token::Pub due to config rule token::*
// Skipping syn::punctuated::Punctuated due to hidden fields
impl<> crate::Debug for syn::QSelf<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("QSelf")
            .field("lt_token", &self.lt_token)
            .field("ty", &self.ty)
            .field("position", &self.position)
            .field("as_token", &self.as_token)
            .field("gt_token", &self.gt_token)
            .finish()
    }
}
// Skiping syn::token::Question due to config rule token::*
// Skiping syn::token::RArrow due to config rule token::*
impl<>  crate::Debug for syn::RangeLimits<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::RangeLimits::HalfOpen (__0, ) => { f.debug_tuple("HalfOpen").field(__0).finish(); }
            syn::RangeLimits::Closed (__0, ) => { f.debug_tuple("Closed").field(__0).finish(); }
        }
    }
}
impl<> crate::Debug for syn::Receiver<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Receiver")
            .field("attrs", &self.attrs)
            .field("reference", &self.reference)
            .field("mutability", &self.mutability)
            .field("self_token", &self.self_token)
            .finish()
    }
}
// Skiping syn::token::Ref due to config rule token::*
// Skiping syn::token::Rem due to config rule token::*
// Skiping syn::token::RemEq due to config rule token::*
// Skiping syn::token::Return due to config rule token::*
impl<>  crate::Debug for syn::ReturnType<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::ReturnType::Default => { f.debug_tuple("Default").finish(); }
            syn::ReturnType::Type (__0, __1, ) => { f.debug_tuple("Type").field(__0).field(__1).finish(); }
        }
    }
}
// Skiping syn::token::SelfType due to config rule token::*
// Skiping syn::token::SelfValue due to config rule token::*
// Skiping syn::token::Semi due to config rule token::*
// Skiping syn::token::Shl due to config rule token::*
// Skiping syn::token::ShlEq due to config rule token::*
// Skiping syn::token::Shr due to config rule token::*
// Skiping syn::token::ShrEq due to config rule token::*
impl<> crate::Debug for syn::Signature<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Signature")
            .field("constness", &self.constness)
            .field("asyncness", &self.asyncness)
            .field("unsafety", &self.unsafety)
            .field("abi", &self.abi)
            .field("fn_token", &self.fn_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("paren_token", &self.paren_token)
            .field("inputs", &self.inputs)
            .field("variadic", &self.variadic)
            .field("output", &self.output)
            .finish()
    }
}
// Skiping syn::token::Star due to config rule token::*
// Skiping syn::token::Static due to config rule token::*
// Skipping syn::parse::StepCursor due to hidden fields
impl<>  crate::Debug for syn::Stmt<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::Stmt::Local (__0, ) => { f.debug_tuple("Local").field(__0).finish(); }
            syn::Stmt::Item (__0, ) => { f.debug_tuple("Item").field(__0).finish(); }
            syn::Stmt::Expr (__0, ) => { f.debug_tuple("Expr").field(__0).finish(); }
            syn::Stmt::Semi (__0, __1, ) => { f.debug_tuple("Semi").field(__0).field(__1).finish(); }
        }
    }
}
impl<>  crate::Debug for syn::StrStyle<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::StrStyle::Cooked => { f.debug_tuple("Cooked").finish(); }
            syn::StrStyle::Raw (__0, ) => { f.debug_tuple("Raw").field(__0).finish(); }
        }
    }
}
// Skiping syn::token::Struct due to config rule token::*
// Skiping syn::token::Sub due to config rule token::*
// Skiping syn::token::SubEq due to config rule token::*
// Skiping syn::token::Super due to config rule token::*
// Skiping syn::token::Tilde due to config rule token::*
// Skipping syn::buffer::TokenBuffer due to hidden fields
// Skiping syn::token::Trait due to config rule token::*
impl<> crate::Debug for syn::TraitBound<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TraitBound")
            .field("paren_token", &self.paren_token)
            .field("modifier", &self.modifier)
            .field("lifetimes", &self.lifetimes)
            .field("path", &self.path)
            .finish()
    }
}
impl<>  crate::Debug for syn::TraitBoundModifier<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::TraitBoundModifier::None => { f.debug_tuple("None").finish(); }
            syn::TraitBoundModifier::Maybe (__0, ) => { f.debug_tuple("Maybe").field(__0).finish(); }
        }
    }
}
impl<>  crate::Debug for syn::TraitItem<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::TraitItem::Const (__0, ) => { f.debug_tuple("Const").field(__0).finish(); }
            syn::TraitItem::Method (__0, ) => { f.debug_tuple("Method").field(__0).finish(); }
            syn::TraitItem::Type (__0, ) => { f.debug_tuple("Type").field(__0).finish(); }
            syn::TraitItem::Macro (__0, ) => { f.debug_tuple("Macro").field(__0).finish(); }
            syn::TraitItem::Verbatim (__0, ) => { f.debug_tuple("Verbatim").field(__0).finish(); }
            _ => { "???".fmt(f) }
        }
    }
}
impl<> crate::Debug for syn::TraitItemConst<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TraitItemConst")
            .field("attrs", &self.attrs)
            .field("const_token", &self.const_token)
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("ty", &self.ty)
            .field("default", &self.default)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl<> crate::Debug for syn::TraitItemMacro<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TraitItemMacro")
            .field("attrs", &self.attrs)
            .field("mac", &self.mac)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl<> crate::Debug for syn::TraitItemMethod<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TraitItemMethod")
            .field("attrs", &self.attrs)
            .field("sig", &self.sig)
            .field("default", &self.default)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
impl<> crate::Debug for syn::TraitItemType<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TraitItemType")
            .field("attrs", &self.attrs)
            .field("type_token", &self.type_token)
            .field("ident", &self.ident)
            .field("generics", &self.generics)
            .field("colon_token", &self.colon_token)
            .field("bounds", &self.bounds)
            .field("default", &self.default)
            .field("semi_token", &self.semi_token)
            .finish()
    }
}
// Skiping syn::token::Try due to config rule token::*
// Skipping syn::Turbofish due to hidden fields
// Skiping syn::token::Type due to config rule token::*
impl<>  crate::Debug for syn::Type<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::Type::Array (__0, ) => { f.debug_tuple("Array").field(__0).finish(); }
            syn::Type::BareFn (__0, ) => { f.debug_tuple("BareFn").field(__0).finish(); }
            syn::Type::Group (__0, ) => { f.debug_tuple("Group").field(__0).finish(); }
            syn::Type::ImplTrait (__0, ) => { f.debug_tuple("ImplTrait").field(__0).finish(); }
            syn::Type::Infer (__0, ) => { f.debug_tuple("Infer").field(__0).finish(); }
            syn::Type::Macro (__0, ) => { f.debug_tuple("Macro").field(__0).finish(); }
            syn::Type::Never (__0, ) => { f.debug_tuple("Never").field(__0).finish(); }
            syn::Type::Paren (__0, ) => { f.debug_tuple("Paren").field(__0).finish(); }
            syn::Type::Path (__0, ) => { f.debug_tuple("Path").field(__0).finish(); }
            syn::Type::Ptr (__0, ) => { f.debug_tuple("Ptr").field(__0).finish(); }
            syn::Type::Reference (__0, ) => { f.debug_tuple("Reference").field(__0).finish(); }
            syn::Type::Slice (__0, ) => { f.debug_tuple("Slice").field(__0).finish(); }
            syn::Type::TraitObject (__0, ) => { f.debug_tuple("TraitObject").field(__0).finish(); }
            syn::Type::Tuple (__0, ) => { f.debug_tuple("Tuple").field(__0).finish(); }
            syn::Type::Verbatim (__0, ) => { f.debug_tuple("Verbatim").field(__0).finish(); }
            _ => { "???".fmt(f) }
        }
    }
}
impl<> crate::Debug for syn::TypeArray<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeArray")
            .field("bracket_token", &self.bracket_token)
            .field("elem", &self.elem)
            .field("semi_token", &self.semi_token)
            .field("len", &self.len)
            .finish()
    }
}
impl<> crate::Debug for syn::TypeBareFn<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeBareFn")
            .field("lifetimes", &self.lifetimes)
            .field("unsafety", &self.unsafety)
            .field("abi", &self.abi)
            .field("fn_token", &self.fn_token)
            .field("paren_token", &self.paren_token)
            .field("inputs", &self.inputs)
            .field("variadic", &self.variadic)
            .field("output", &self.output)
            .finish()
    }
}
// Skipping syn::TypeGenerics due to hidden fields
impl<> crate::Debug for syn::TypeGroup<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeGroup")
            .field("group_token", &self.group_token)
            .field("elem", &self.elem)
            .finish()
    }
}
impl<> crate::Debug for syn::TypeImplTrait<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeImplTrait")
            .field("impl_token", &self.impl_token)
            .field("bounds", &self.bounds)
            .finish()
    }
}
impl<> crate::Debug for syn::TypeInfer<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeInfer")
            .field("underscore_token", &self.underscore_token)
            .finish()
    }
}
impl<> crate::Debug for syn::TypeMacro<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeMacro")
            .field("mac", &self.mac)
            .finish()
    }
}
impl<> crate::Debug for syn::TypeNever<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeNever")
            .field("bang_token", &self.bang_token)
            .finish()
    }
}
impl<> crate::Debug for syn::TypeParam<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeParam")
            .field("attrs", &self.attrs)
            .field("ident", &self.ident)
            .field("colon_token", &self.colon_token)
            .field("bounds", &self.bounds)
            .field("eq_token", &self.eq_token)
            .field("default", &self.default)
            .finish()
    }
}
impl<>  crate::Debug for syn::TypeParamBound<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::TypeParamBound::Trait (__0, ) => { f.debug_tuple("Trait").field(__0).finish(); }
            syn::TypeParamBound::Lifetime (__0, ) => { f.debug_tuple("Lifetime").field(__0).finish(); }
        }
    }
}
impl<> crate::Debug for syn::TypeParen<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeParen")
            .field("paren_token", &self.paren_token)
            .field("elem", &self.elem)
            .finish()
    }
}
impl<> crate::Debug for syn::TypePath<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypePath")
            .field("qself", &self.qself)
            .field("path", &self.path)
            .finish()
    }
}
impl<> crate::Debug for syn::TypePtr<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypePtr")
            .field("star_token", &self.star_token)
            .field("const_token", &self.const_token)
            .field("mutability", &self.mutability)
            .field("elem", &self.elem)
            .finish()
    }
}
impl<> crate::Debug for syn::TypeReference<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeReference")
            .field("and_token", &self.and_token)
            .field("lifetime", &self.lifetime)
            .field("mutability", &self.mutability)
            .field("elem", &self.elem)
            .finish()
    }
}
impl<> crate::Debug for syn::TypeSlice<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeSlice")
            .field("bracket_token", &self.bracket_token)
            .field("elem", &self.elem)
            .finish()
    }
}
impl<> crate::Debug for syn::TypeTraitObject<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeTraitObject")
            .field("dyn_token", &self.dyn_token)
            .field("bounds", &self.bounds)
            .finish()
    }
}
impl<> crate::Debug for syn::TypeTuple<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("TypeTuple")
            .field("paren_token", &self.paren_token)
            .field("elems", &self.elems)
            .finish()
    }
}
// Skiping syn::token::Typeof due to config rule token::*
impl<>  crate::Debug for syn::UnOp<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::UnOp::Deref (__0, ) => { f.debug_tuple("Deref").field(__0).finish(); }
            syn::UnOp::Not (__0, ) => { f.debug_tuple("Not").field(__0).finish(); }
            syn::UnOp::Neg (__0, ) => { f.debug_tuple("Neg").field(__0).finish(); }
        }
    }
}
// Skiping syn::token::Underscore due to config rule token::*
// Skiping syn::token::Union due to config rule token::*
// Skiping syn::token::Unsafe due to config rule token::*
// Skiping syn::token::Unsized due to config rule token::*
// Skiping syn::token::Use due to config rule token::*
impl<> crate::Debug for syn::UseGlob<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("UseGlob")
            .field("star_token", &self.star_token)
            .finish()
    }
}
impl<> crate::Debug for syn::UseGroup<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("UseGroup")
            .field("brace_token", &self.brace_token)
            .field("items", &self.items)
            .finish()
    }
}
impl<> crate::Debug for syn::UseName<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("UseName")
            .field("ident", &self.ident)
            .finish()
    }
}
impl<> crate::Debug for syn::UsePath<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("UsePath")
            .field("ident", &self.ident)
            .field("colon2_token", &self.colon2_token)
            .field("tree", &self.tree)
            .finish()
    }
}
impl<> crate::Debug for syn::UseRename<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("UseRename")
            .field("ident", &self.ident)
            .field("as_token", &self.as_token)
            .field("rename", &self.rename)
            .finish()
    }
}
impl<>  crate::Debug for syn::UseTree<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::UseTree::Path (__0, ) => { f.debug_tuple("Path").field(__0).finish(); }
            syn::UseTree::Name (__0, ) => { f.debug_tuple("Name").field(__0).finish(); }
            syn::UseTree::Rename (__0, ) => { f.debug_tuple("Rename").field(__0).finish(); }
            syn::UseTree::Glob (__0, ) => { f.debug_tuple("Glob").field(__0).finish(); }
            syn::UseTree::Group (__0, ) => { f.debug_tuple("Group").field(__0).finish(); }
        }
    }
}
impl<> crate::Debug for syn::Variadic<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Variadic")
            .field("attrs", &self.attrs)
            .field("dots", &self.dots)
            .finish()
    }
}
impl<> crate::Debug for syn::Variant<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("Variant")
            .field("attrs", &self.attrs)
            .field("ident", &self.ident)
            .field("fields", &self.fields)
            .field("discriminant", &self.discriminant)
            .finish()
    }
}
// Skiping syn::token::Virtual due to config rule token::*
impl<> crate::Debug for syn::VisCrate<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("VisCrate")
            .field("crate_token", &self.crate_token)
            .finish()
    }
}
impl<> crate::Debug for syn::VisPublic<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("VisPublic")
            .field("pub_token", &self.pub_token)
            .finish()
    }
}
impl<> crate::Debug for syn::VisRestricted<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("VisRestricted")
            .field("pub_token", &self.pub_token)
            .field("paren_token", &self.paren_token)
            .field("in_token", &self.in_token)
            .field("path", &self.path)
            .finish()
    }
}
impl<>  crate::Debug for syn::Visibility<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::Visibility::Public (__0, ) => { f.debug_tuple("Public").field(__0).finish(); }
            syn::Visibility::Crate (__0, ) => { f.debug_tuple("Crate").field(__0).finish(); }
            syn::Visibility::Restricted (__0, ) => { f.debug_tuple("Restricted").field(__0).finish(); }
            syn::Visibility::Inherited => { f.debug_tuple("Inherited").finish(); }
        }
    }
}
// Skiping syn::token::Where due to config rule token::*
impl<> crate::Debug for syn::WhereClause<>  where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        f.debug_struct("WhereClause")
            .field("where_token", &self.where_token)
            .field("predicates", &self.predicates)
            .finish()
    }
}
impl<>  crate::Debug for syn::WherePredicate<> where  {
    fn fmt(&self, f: &mut crate::Formatter) {
        match self {
            syn::WherePredicate::Type (__0, ) => { f.debug_tuple("Type").field(__0).finish(); }
            syn::WherePredicate::Lifetime (__0, ) => { f.debug_tuple("Lifetime").field(__0).finish(); }
            syn::WherePredicate::Eq (__0, ) => { f.debug_tuple("Eq").field(__0).finish(); }
        }
    }
}
// Skiping syn::token::While due to config rule token::*
// Skiping syn::token::Yield due to config rule token::*
